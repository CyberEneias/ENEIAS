-- ===== AUTOFARM ULTRA-LEVE COM ANTI-KNOCKBACK, INFINITE JUMP E VELOCITY SPEED =====
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer
if not player then return end

-- ===== CONSTANTES =====
local CONFIG = {
	BACK_DISTANCE = 3.5,
	HEIGHT_OFFSET = 2.5,
	MAX_DISTANCE = 60,
	UPDATE_INTERVAL = 1,
	GUI_NAME = "InfoExperienciaGui",
	NPC_SCAN_INTERVAL = 0.5, -- Escaneia NPCs apenas a cada 0.5s
	NPC_CACHE_SIZE = 50 -- Limita busca a 50 NPCs mais próximos
}

local COLORS = {
	BACKGROUND = Color3.fromRGB(20, 20, 20),
	CLOSE_BTN = Color3.fromRGB(255, 50, 50),
	BTN_OFF = Color3.fromRGB(40, 40, 40),
	BTN_ON = Color3.fromRGB(0, 140, 0),
	TEXT = Color3.fromRGB(255, 255, 255),
	TEXT_SECONDARY = Color3.fromRGB(200, 200, 200),
	INPUT_BG = Color3.fromRGB(30, 30, 30)
}

-- ===== CACHE =====
local workspace = workspace
local Vector3_new = Vector3.new
local Vector3_zero = Vector3.zero
local CFrame_new = CFrame.new
local UDim2_new = UDim2.new

-- ===== STATE =====
local state = {
	autofarmEnabled = false,
	infiniteJumpEnabled = false,
	speedEnabled = false,
	speedValue = 50,
	lockedNPC = nil,
	lastNPCScan = 0,
	npcCache = {}, -- Cache de NPCs válidos
	connections = {}
}

-- ===== UTILITY FUNCTIONS =====
local function cleanupOldGui()
	local oldGui = CoreGui:FindFirstChild(CONFIG.GUI_NAME)
	if oldGui then
		oldGui:Destroy()
	end
end

local function createUICorner(radius, parent)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function disconnectConnection(name)
	if state.connections[name] then
		state.connections[name]:Disconnect()
		state.connections[name] = nil
	end
end

-- ===== GUI CREATION =====
cleanupOldGui()

local screenGui = Instance.new("ScreenGui")
screenGui.Name = CONFIG.GUI_NAME
screenGui.ResetOnSpawn = false
screenGui.Parent = CoreGui

local frame = Instance.new("Frame")
frame.Parent = screenGui
frame.Size = UDim2_new(0, 520, 0, 180)
frame.Position = UDim2_new(0, 40, 0, 40)
frame.BackgroundColor3 = COLORS.BACKGROUND
frame.BorderSizePixel = 0
frame.Active = true
createUICorner(12, frame)

-- Texto principal
local textLabel = Instance.new("TextLabel")
textLabel.Parent = frame
textLabel.Size = UDim2_new(1, -20, 1, -100)
textLabel.Position = UDim2_new(0, 10, 0, 10)
textLabel.BackgroundTransparency = 1
textLabel.TextColor3 = COLORS.TEXT
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextWrapped = true
textLabel.TextScaled = true
textLabel.TextXAlignment = Enum.TextXAlignment.Left
textLabel.TextYAlignment = Enum.TextYAlignment.Top

-- Status do NPC
local statusLabel = Instance.new("TextLabel")
statusLabel.Parent = frame
statusLabel.Size = UDim2_new(1, -20, 0, 20)
statusLabel.Position = UDim2_new(0, 10, 1, -80)
statusLabel.BackgroundTransparency = 1
statusLabel.TextColor3 = COLORS.TEXT_SECONDARY
statusLabel.Font = Enum.Font.SourceSans
statusLabel.TextSize = 14
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Text = "NPC: Nenhum"

-- Botão de fechar
local closeButton = Instance.new("TextButton")
closeButton.Parent = frame
closeButton.Size = UDim2_new(0, 30, 0, 30)
closeButton.Position = UDim2_new(1, -35, 0, 5)
closeButton.BackgroundColor3 = COLORS.CLOSE_BTN
closeButton.TextColor3 = COLORS.TEXT
closeButton.Font = Enum.Font.SourceSansBold
closeButton.Text = "X"
closeButton.TextSize = 18
createUICorner(8, closeButton)

-- ===== DRAG FUNCTIONALITY =====
do
	local dragging, dragStart, startPos = false, nil, nil

	local function updateDrag(input)
		local delta = input.Position - dragStart
		frame.Position = UDim2_new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	end

	frame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
		   input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or 
		                 input.UserInputType == Enum.UserInputType.Touch) then
			updateDrag(input)
		end
	end)
end

-- ===== AUTOFARM ULTRA-LEVE =====
local toggleButton = Instance.new("TextButton")
toggleButton.Parent = frame
toggleButton.Size = UDim2_new(0, 160, 0, 40)
toggleButton.Position = UDim2_new(1, -170, 1, -50)
toggleButton.BackgroundColor3 = COLORS.BTN_OFF
toggleButton.TextColor3 = COLORS.TEXT
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 18
toggleButton.Text = "Autofarm: OFF"
createUICorner(8, toggleButton)

-- Cache de NPCs para evitar GetDescendants repetido
local function updateNPCCache()
	table.clear(state.npcCache)
	
	local character = player.Character
	if not character then return end
	
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end
	
	local rootPos = root.Position
	local count = 0
	
	-- Busca apenas em Workspace (não GetDescendants recursivo)
	for _, child in ipairs(workspace:GetChildren()) do
		if count >= CONFIG.NPC_CACHE_SIZE then break end
		
		if child:IsA("Model") and child ~= character then
			local humanoid = child:FindFirstChild("Humanoid")
			local npcRoot = child:FindFirstChild("HumanoidRootPart")
			
			if humanoid and npcRoot and humanoid.Health > 0 and
			   not Players:GetPlayerFromCharacter(child) then
				
				-- Só adiciona NPCs dentro do alcance máximo
				local distance = (rootPos - npcRoot.Position).Magnitude
				if distance <= CONFIG.MAX_DISTANCE then
					table.insert(state.npcCache, {
						model = child,
						root = npcRoot,
						distance = distance
					})
					count = count + 1
				end
			end
		end
	end
	
	-- Ordena por distância (mais próximo primeiro)
	table.sort(state.npcCache, function(a, b)
		return a.distance < b.distance
	end)
end

-- Encontra o NPC mais próximo usando cache
local function findClosestNPC()
	-- Atualiza cache apenas se passou tempo suficiente
	local currentTime = tick()
	if currentTime - state.lastNPCScan >= CONFIG.NPC_SCAN_INTERVAL then
		updateNPCCache()
		state.lastNPCScan = currentTime
	end
	
	-- Retorna o primeiro NPC válido do cache
	for _, npcData in ipairs(state.npcCache) do
		local model = npcData.model
		if model and model.Parent then
			local humanoid = model:FindFirstChild("Humanoid")
			if humanoid and humanoid.Health > 0 then
				return model
			end
		end
	end
	
	return nil
end

-- Valida se o NPC travado ainda é válido
local function isNPCValid(npc)
	if not npc or not npc.Parent then return false end
	
	local humanoid = npc:FindFirstChild("Humanoid")
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	
	if not humanoid or not npcRoot or humanoid.Health <= 0 then
		return false
	end
	
	-- Verifica se ainda está no alcance
	local character = player.Character
	if not character then return false end
	
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return false end
	
	local distance = (root.Position - npcRoot.Position).Magnitude
	return distance <= CONFIG.MAX_DISTANCE
end

-- Loop principal ULTRA-LEVE
local function autofarmLoop()
	if not state.autofarmEnabled then return end
	
	local character = player.Character
	if not character then return end
	
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end

	-- Valida ou busca novo NPC
	if not isNPCValid(state.lockedNPC) then
		state.lockedNPC = findClosestNPC()
	end

	local npc = state.lockedNPC
	if not npc then
		statusLabel.Text = "NPC: Nenhum"
		return
	end

	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not npcRoot then
		state.lockedNPC = nil
		return
	end

	-- Calcula posição fixa atrás do NPC
	local npcCFrame = npcRoot.CFrame
	local backOffset = -npcCFrame.LookVector * CONFIG.BACK_DISTANCE
	local heightOffset = Vector3_new(0, CONFIG.HEIGHT_OFFSET, 0)
	local targetPos = npcRoot.Position + backOffset + heightOffset

	-- Anti-knockback (zera velocidades)
	root.AssemblyLinearVelocity = Vector3_zero
	root.AssemblyAngularVelocity = Vector3_zero
	
	-- Teleporta para posição fixa
	root.CFrame = CFrame_new(targetPos)
	
	-- Atualiza status
	statusLabel.Text = "NPC: " .. npc.Name
end

toggleButton.MouseButton1Click:Connect(function()
	state.autofarmEnabled = not state.autofarmEnabled
	
	if state.autofarmEnabled then
		disconnectConnection("autofarm")
		
		-- Limpa cache ao iniciar
		state.lastNPCScan = 0
		table.clear(state.npcCache)
		
		-- Conecta no RenderStepped (mais leve que Heartbeat)
		state.connections.autofarm = RunService.RenderStepped:Connect(autofarmLoop)
		
		toggleButton.Text = "Autofarm: ON"
		toggleButton.BackgroundColor3 = COLORS.BTN_ON
	else
		disconnectConnection("autofarm")
		state.lockedNPC = nil
		table.clear(state.npcCache)
		
		toggleButton.Text = "Autofarm: OFF"
		toggleButton.BackgroundColor3 = COLORS.BTN_OFF
		statusLabel.Text = "NPC: Nenhum"
	end
end)

-- ===== INFINITE JUMP =====
local infiniteJumpButton = Instance.new("TextButton")
infiniteJumpButton.Parent = frame
infiniteJumpButton.Size = UDim2_new(0, 160, 0, 40)
infiniteJumpButton.Position = UDim2_new(0, 10, 1, -50)
infiniteJumpButton.BackgroundColor3 = COLORS.BTN_OFF
infiniteJumpButton.TextColor3 = COLORS.TEXT
infiniteJumpButton.Font = Enum.Font.SourceSansBold
infiniteJumpButton.TextSize = 18
infiniteJumpButton.Text = "Infinite Jump: OFF"
createUICorner(8, infiniteJumpButton)

infiniteJumpButton.MouseButton1Click:Connect(function()
	state.infiniteJumpEnabled = not state.infiniteJumpEnabled
	
	if state.infiniteJumpEnabled then
		infiniteJumpButton.Text = "Infinite Jump: ON"
		infiniteJumpButton.BackgroundColor3 = COLORS.BTN_ON
	else
		infiniteJumpButton.Text = "Infinite Jump: OFF"
		infiniteJumpButton.BackgroundColor3 = COLORS.BTN_OFF
	end
end)

UserInputService.JumpRequest:Connect(function()
	if not state.infiniteJumpEnabled then return end
	
	local character = player.Character
	if not character then return end
	
	local humanoid = character:FindFirstChild("Humanoid")
	if humanoid then
		humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	end
end)

-- ===== VELOCITY SPEED =====
local speedLabel = Instance.new("TextLabel")
speedLabel.Parent = frame
speedLabel.Size = UDim2_new(0, 160, 0, 20)
speedLabel.Position = UDim2_new(0, 190, 1, -90)
speedLabel.BackgroundTransparency = 1
speedLabel.Text = "Velocity Speed:"
speedLabel.TextColor3 = COLORS.TEXT
speedLabel.Font = Enum.Font.SourceSans
speedLabel.TextSize = 14
speedLabel.TextXAlignment = Enum.TextXAlignment.Left

local speedBox = Instance.new("TextBox")
speedBox.Parent = frame
speedBox.Size = UDim2_new(0, 80, 0, 30)
speedBox.Position = UDim2_new(0, 190, 1, -65)
speedBox.BackgroundColor3 = COLORS.INPUT_BG
speedBox.TextColor3 = COLORS.TEXT
speedBox.Font = Enum.Font.SourceSansBold
speedBox.TextSize = 16
speedBox.PlaceholderText = "Ex: 80"
speedBox.Text = tostring(state.speedValue)
speedBox.ClearTextOnFocus = false
createUICorner(6, speedBox)

local speedToggle = Instance.new("TextButton")
speedToggle.Parent = frame
speedToggle.Size = UDim2_new(0, 160, 0, 35)
speedToggle.Position = UDim2_new(0, 280, 1, -67)
speedToggle.BackgroundColor3 = COLORS.BTN_OFF
speedToggle.TextColor3 = COLORS.TEXT
speedToggle.Font = Enum.Font.SourceSansBold
speedToggle.TextSize = 16
speedToggle.Text = "Speed: OFF"
createUICorner(8, speedToggle)

local function velocitySpeedLoop()
	if not state.speedEnabled then return end

	local char = player.Character
	if not char then return end

	local root = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChildOfClass("Humanoid")

	if root and hum then
		local moveDir = hum.MoveDirection
		if moveDir.Magnitude > 0 then
			local currentY = root.AssemblyLinearVelocity.Y
			root.AssemblyLinearVelocity = (moveDir.Unit * state.speedValue) + 
			                               Vector3_new(0, currentY, 0)
		end
	end
end

local function startVelocitySpeed()
	disconnectConnection("speed")
	state.connections.speed = RunService.Heartbeat:Connect(velocitySpeedLoop)
end

speedToggle.MouseButton1Click:Connect(function()
	state.speedEnabled = not state.speedEnabled

	if state.speedEnabled then
		local value = tonumber(speedBox.Text)
		if value and value > 0 then
			state.speedValue = value
		end

		speedToggle.Text = "Speed: ON"
		speedToggle.BackgroundColor3 = COLORS.BTN_ON
		startVelocitySpeed()
	else
		speedToggle.Text = "Speed: OFF"
		speedToggle.BackgroundColor3 = COLORS.BTN_OFF
		disconnectConnection("speed")
	end
end)

speedBox.FocusLost:Connect(function()
	local value = tonumber(speedBox.Text)
	if value and value > 0 then
		state.speedValue = value
	end
end)

-- ===== UPDATES =====
task.spawn(function()
	local nomeExperiencia = game.Name
	while frame.Parent do
		textLabel.Text = string.format(
			"Experiência em Teste:\n%s\n\nData e Hora:\n%s",
			nomeExperiencia,
			os.date("%d/%m/%Y - %H:%M:%S")
		)
		task.wait(CONFIG.UPDATE_INTERVAL)
	end
end)

-- ===== CLEANUP =====
closeButton.MouseButton1Click:Connect(function()
	screenGui:Destroy()
end)

screenGui.Destroying:Connect(function()
	for name, _ in pairs(state.connections) do
		disconnectConnection(name)
	end
	table.clear(state.npcCache)
end)

player.CharacterAdded:Connect(function()
	task.wait(0.3)
	if state.speedEnabled then
		startVelocitySpeed()
	end
end)
