--//====================================================--
--//           CYBER HUB - FFRE EDITION V4.3           --
--//====================================================--
--//  Ultra Smooth Teleport (Anti-Kick) + Lock On       --
--//  ESP + Tracers + Health Bars (Workspace.Alive)     --
--//  Dual Autofarm Mode: Behind / Above NPC            --
--//====================================================--

local CyberHub = (function()

--//====================================================--
--//                   CORE SYSTEM                      --
--//====================================================--

local Core = (function()
	-- Servi√ßos do Roblox
	local Services = {
		Players         = game:GetService("Players"),
		RunService      = game:GetService("RunService"),
		UserInputService= game:GetService("UserInputService"),
		CoreGui         = game:GetService("CoreGui"),
		TweenService    = game:GetService("TweenService"),
	}

	-- Configura√ß√£o central (altere valores aqui)
	local CONFIG = {
		BACK_DISTANCE         = 3.5,
		HEIGHT_OFFSET         = 2.5,
		ABOVE_HEIGHT          = 8,
		MAX_DISTANCE          = 60,
		NPC_SCAN_INTERVAL     = 0.3,
		M1_CLICK_DELAY        = 0.15,
		CHAR_CACHE_UPDATE     = 0.5,
		GUI_NAME              = "CyberHub",
		TELEPORT_SPEED        = 150,
		MAX_TELEPORT_DISTANCE = 500,
		VISUAL_NPC_FOLDER     = workspace:WaitForChild("Alive"),
		TELEPORT_NPC_FOLDER   = workspace:WaitForChild("LiveNPCS"),
	}

	-- Estado global centralizado (sem vari√°veis globais soltas)
	local State = {
		-- Features
		autofarmEnabled    = false,
		autofarmMode       = "Behind",
		autofarmDistance   = 8,
		infiniteJumpEnabled= false,
		speedEnabled       = false,
		m1MacroEnabled     = false,
		espEnabled         = false,
		tracersEnabled     = false,
		healthBarsEnabled  = false,
		lockOnEnabled      = false,
		noClipEnabled      = false,
		playerESPEnabled   = false,
		fovEnabled         = false,

		-- Valores
		speedValue    = 160,
		m1ClickDelay  = 0.15,

		-- Refer√™ncias de NPC/alvo
		lockedNPC    = nil,
		lockedTarget = nil,

		-- Timers / cache
		lastNPCScan   = 0,
		npcCache      = {},
		lastM1Click   = 0,
		lastSpeedApply= 0,
		charCache     = { root=nil, humanoid=nil, character=nil, lastUpdate=0 },

		-- Conex√µes do RunService
		connections = {},

		-- Objetos visuais
		espObjects       = {},
		tracerLines      = {},
		healthBarObjects = {},
		playerESPObjects = {},
		fovDrawingCircle = nil,    -- Objeto Drawing (diferente do fovToggleCircle da GUI)
		teleportNPCList  = {},

		-- GUI
		guiVisible   = true,
		currentPage  = "combat",
		isTeleporting= false,
	}

	-- Cache de construtores frequentes (performance)
	local Cache = {
		Vector3_new    = Vector3.new,
		Vector3_zero   = Vector3.zero,
		CFrame_new     = CFrame.new,
		UDim2_new      = UDim2.new,
		Color3_fromRGB = Color3.fromRGB,
		Color3_white   = Color3.new(1,1,1),
		Color3_black   = Color3.new(0,0,0),
	}

	return { Services=Services, CONFIG=CONFIG, State=State, Cache=Cache }
end)()

--//====================================================--
--//                  UTILS SYSTEM                      --
--//====================================================--

local Utils = (function()
	local State    = Core.State
	local CONFIG   = Core.CONFIG
	local Cache    = Core.Cache
	local Services = Core.Services
	local player   = Services.Players.LocalPlayer

	-- Desconecta uma conex√£o por nome
	local function disconnectConnection(name)
		if State.connections[name] then
			State.connections[name]:Disconnect()
			State.connections[name] = nil
		end
	end

	-- Desconecta todas as conex√µes ativas
	local function cleanAllConnections()
		for name, conn in pairs(State.connections) do
			if conn and conn.Connected then
				conn:Disconnect()
			end
		end
		table.clear(State.connections)
	end

	-- Retorna componentes do personagem com cache
	local function getCharComponents()
		local now = tick()
		if now - State.charCache.lastUpdate > CONFIG.CHAR_CACHE_UPDATE then
			local char = player.Character
			State.charCache.character = char
			State.charCache.root      = char and char:FindFirstChild("HumanoidRootPart")
			State.charCache.humanoid  = char and char:FindFirstChildOfClass("Humanoid")
			State.charCache.lastUpdate= now
		end
		return State.charCache.root, State.charCache.humanoid, State.charCache.character
	end

	-- For√ßa atualiza√ß√£o do cache do personagem
	local function invalidateCharCache()
		State.charCache.lastUpdate = 0
	end

	-- Anima toggle (tween visual)
	local function animateToggle(bg, circle, enabled)
		local TweenService = Services.TweenService
		local Cache        = Core.Cache
		TweenService:Create(bg, TweenInfo.new(0.2), {
			BackgroundColor3 = enabled
				and Cache.Color3_fromRGB(100, 180, 255)
				or  Cache.Color3_fromRGB(40, 40, 55)
		}):Play()
		TweenService:Create(circle, TweenInfo.new(0.2), {
			Position = enabled
				and Cache.UDim2_new(1, -18, 0.5, -8)
				or  Cache.UDim2_new(0, 2, 0.5, -8)
		}):Play()
	end

	return {
		disconnectConnection = disconnectConnection,
		cleanAllConnections  = cleanAllConnections,
		getCharComponents    = getCharComponents,
		invalidateCharCache  = invalidateCharCache,
		animateToggle        = animateToggle,
	}
end)()

--//====================================================--
--//               FEATURE REGISTRY                     --
--//====================================================--

local Registry = (function()
	-- Tabela central de m√≥dulos registrados
	local FeatureRegistry = {}

	-- Registra um m√≥dulo de feature
	local function RegisterFeature(name, module)
		FeatureRegistry[name] = module
	end

	-- Obt√©m m√≥dulo registrado
	local function GetFeature(name)
		return FeatureRegistry[name]
	end

	-- Lista todas features registradas
	local function GetAll()
		return FeatureRegistry
	end

	return {
		register = RegisterFeature,
		get      = GetFeature,
		getAll   = GetAll,
	}
end)()

--//====================================================--
--//                 NPC CACHE SYSTEM                   --
--//====================================================--

local NPCCache = (function()
	local State    = Core.State
	local CONFIG   = Core.CONFIG
	local Services = Core.Services
	local player   = Services.Players.LocalPlayer

	-- Atualiza lista de NPCs pr√≥ximos e os ordena por dist√¢ncia
	local function updateCache()
		table.clear(State.npcCache)
		local root = Utils.getCharComponents()
		if not root then return end

		for _, npc in ipairs(CONFIG.VISUAL_NPC_FOLDER:GetChildren()) do
			if npc:IsA("Model") and npc ~= player.Character then
				local hum     = npc:FindFirstChild("Humanoid")
				local npcRoot = npc:FindFirstChild("HumanoidRootPart")
				if hum and npcRoot and hum.Health > 0 then
					local dist = (root.Position - npcRoot.Position).Magnitude
					if dist <= CONFIG.MAX_DISTANCE then
						table.insert(State.npcCache, {
							model    = npc,
							root     = npcRoot,
							humanoid = hum,
							distance = dist,
						})
					end
				end
			end
		end

		table.sort(State.npcCache, function(a, b) return a.distance < b.distance end)
	end

	-- Retorna o NPC mais pr√≥ximo (com cooldown de scan)
	local function findClosest()
		local now = tick()
		if now - State.lastNPCScan > CONFIG.NPC_SCAN_INTERVAL then
			updateCache()
			State.lastNPCScan = now
		end
		return State.npcCache[1] and State.npcCache[1].model
	end

	-- Valida se um NPC ainda √© farm√°vel
	local function isValid(npc)
		if not npc or not npc.Parent then return false end
		local hum     = npc:FindFirstChild("Humanoid")
		local npcRoot = npc:FindFirstChild("HumanoidRootPart")
		if not hum or not npcRoot or hum.Health <= 0 then return false end

		local root = Utils.getCharComponents()
		if not root then return false end

		return (root.Position - npcRoot.Position).Magnitude <= Core.CONFIG.MAX_DISTANCE
	end

	return {
		update       = updateCache,
		findClosest  = findClosest,
		isValid      = isValid,
	}
end)()

--//====================================================--
--//                   ESP SYSTEM                       --
--//====================================================--

local ESP = (function()
	local State  = Core.State
	local Cache  = Core.Cache

	--// NPC ESP (Highlight) //--
	local function createESP(npc)
		if State.espObjects[npc] then return end
		if not npc:FindFirstChild("HumanoidRootPart") then return end

		local highlight = Instance.new("Highlight")
		highlight.Name             = "CyberHighlight"
		highlight.Adornee          = npc
		highlight.FillColor        = Cache.Color3_fromRGB(255, 0, 0)
		highlight.OutlineColor     = Cache.Color3_fromRGB(255, 255, 255)
		highlight.FillTransparency = 0.5
		highlight.OutlineTransparency = 0
		highlight.Parent           = npc

		State.espObjects[npc] = highlight
	end

	local function removeESP(npc)
		if State.espObjects[npc] then
			State.espObjects[npc]:Destroy()
			State.espObjects[npc] = nil
		end
	end

	local function clearAllESP()
		for _, esp in pairs(State.espObjects) do
			if esp then esp:Destroy() end
		end
		table.clear(State.espObjects)
	end

	--// Tracers (Drawing Lines) //--
	local function createTracer(npc)
		if State.tracerLines[npc] then return end
		if not npc:FindFirstChild("HumanoidRootPart") then return end

		local line         = Drawing.new("Line")
		line.Visible       = true
		line.Color         = Color3.new(0, 1, 0)
		line.Thickness     = 2
		line.Transparency  = 0.7

		State.tracerLines[npc] = line
	end

	local function updateTracers()
		if not State.tracersEnabled then return end
		local camera = workspace.CurrentCamera

		for npc, line in pairs(State.tracerLines) do
			if npc and npc.Parent then
				local npcRoot = npc:FindFirstChild("HumanoidRootPart")
				if npcRoot then
					local npcPos, onScreen = camera:WorldToViewportPoint(npcRoot.Position)
					local screenSize = camera.ViewportSize

					if onScreen then
						line.From    = Vector2.new(screenSize.X / 2, screenSize.Y)
						line.To      = Vector2.new(npcPos.X, npcPos.Y)
						line.Visible = true
					else
						line.Visible = false
					end
				else
					line.Visible = false
				end
			else
				line.Visible = false
			end
		end
	end

	local function removeTracer(npc)
		if State.tracerLines[npc] then
			State.tracerLines[npc]:Remove()
			State.tracerLines[npc] = nil
		end
	end

	local function clearAllTracers()
		for _, line in pairs(State.tracerLines) do
			if line then line:Remove() end
		end
		table.clear(State.tracerLines)
	end

	--// Health Bars (BillboardGui) //--
	local function createHealthBar(npc)
		if State.healthBarObjects[npc] then return end
		local npcRoot = npc:FindFirstChild("HumanoidRootPart")
		local npcHum  = npc:FindFirstChild("Humanoid")
		if not npcRoot or not npcHum then return end

		local billboard       = Instance.new("BillboardGui")
		billboard.Name        = "CyberHealthBar"
		billboard.Adornee     = npcRoot
		billboard.Size        = Cache.UDim2_new(4, 0, 0.5, 0)
		billboard.StudsOffset = Cache.Vector3_new(0, 3, 0)
		billboard.AlwaysOnTop = true
		billboard.Parent      = npc

		local bg              = Instance.new("Frame")
		bg.Size               = Cache.UDim2_new(1, 0, 1, 0)
		bg.BackgroundColor3   = Cache.Color3_fromRGB(40, 40, 40)
		bg.BorderSizePixel    = 0
		bg.Parent             = billboard

		local bar             = Instance.new("Frame")
		bar.Name              = "HealthBar"
		bar.Size              = Cache.UDim2_new(npcHum.Health / npcHum.MaxHealth, 0, 1, 0)
		bar.BackgroundColor3  = Cache.Color3_fromRGB(0, 255, 0)
		bar.BorderSizePixel   = 0
		bar.Parent            = bg

		local txt             = Instance.new("TextLabel")
		txt.Name              = "HealthText"
		txt.Size              = Cache.UDim2_new(1, 0, 1, 0)
		txt.BackgroundTransparency = 1
		txt.Text              = math.floor(npcHum.Health) .. "/" .. math.floor(npcHum.MaxHealth)
		txt.TextColor3        = Cache.Color3_white
		txt.TextScaled        = true
		txt.Font              = Enum.Font.GothamBold
		txt.Parent            = bg

		-- Bordas arredondadas
		local c1 = Instance.new("UICorner"); c1.CornerRadius = UDim.new(0,4); c1.Parent = bg
		local c2 = Instance.new("UICorner"); c2.CornerRadius = UDim.new(0,4); c2.Parent = bar

		State.healthBarObjects[npc] = billboard
	end

	local function updateHealthBar(npc)
		local gui = State.healthBarObjects[npc]
		if not gui then return end

		local npcHum = npc:FindFirstChild("Humanoid")
		if not npcHum then return end

		local frame     = gui:FindFirstChild("Frame")
		local bar       = frame and frame:FindFirstChild("HealthBar")
		local txt       = frame and frame:FindFirstChild("HealthText")
		if not bar or not txt then return end

		local pct = npcHum.Health / npcHum.MaxHealth
		bar.Size  = Cache.UDim2_new(pct, 0, 1, 0)
		txt.Text  = math.floor(npcHum.Health) .. "/" .. math.floor(npcHum.MaxHealth)

		if pct > 0.5 then
			bar.BackgroundColor3 = Cache.Color3_fromRGB(0, 255, 0)
		elseif pct > 0.25 then
			bar.BackgroundColor3 = Cache.Color3_fromRGB(255, 255, 0)
		else
			bar.BackgroundColor3 = Cache.Color3_fromRGB(255, 0, 0)
		end
	end

	local function removeHealthBar(npc)
		if State.healthBarObjects[npc] then
			State.healthBarObjects[npc]:Destroy()
			State.healthBarObjects[npc] = nil
		end
	end

	local function clearAllHealthBars()
		for _, gui in pairs(State.healthBarObjects) do
			if gui then gui:Destroy() end
		end
		table.clear(State.healthBarObjects)
	end

	--// Player ESP //--
	local function updatePlayerESP()
		local Services = Core.Services
		local player   = Services.Players.LocalPlayer

		if not State.playerESPEnabled then
			for _, esp in pairs(State.playerESPObjects) do
				if esp then esp:Destroy() end
			end
			table.clear(State.playerESPObjects)
			return
		end

		for _, otherPlayer in ipairs(Services.Players:GetPlayers()) do
			if otherPlayer ~= player and otherPlayer.Character then
				local char = otherPlayer.Character
				if not State.playerESPObjects[otherPlayer] then
					local hl              = Instance.new("Highlight")
					hl.Name               = "PlayerHighlight"
					hl.Adornee            = char
					hl.FillColor          = Cache.Color3_fromRGB(0, 255, 255)
					hl.OutlineColor       = Cache.Color3_fromRGB(255, 255, 255)
					hl.FillTransparency   = 0.7
					hl.OutlineTransparency= 0
					hl.Parent             = char
					State.playerESPObjects[otherPlayer] = hl
				end
			end
		end
	end

	--// FOV Circle (Drawing) //--
	local function createFOVCircle()
		if State.fovDrawingCircle then return end
		local c          = Drawing.new("Circle")
		c.Visible        = true
		c.Thickness      = 2
		c.Color          = Color3.new(1, 1, 1)
		c.Transparency   = 0.7
		c.NumSides       = 60
		c.Radius         = 150
		c.Filled         = false
		State.fovDrawingCircle = c
	end

	local function updateFOVCircle()
		if not State.fovEnabled or not State.fovDrawingCircle then return end
		local sz = workspace.CurrentCamera.ViewportSize
		State.fovDrawingCircle.Position = Vector2.new(sz.X / 2, sz.Y / 2)
		State.fovDrawingCircle.Visible  = true
	end

	local function removeFOVCircle()
		if State.fovDrawingCircle then
			State.fovDrawingCircle:Remove()
			State.fovDrawingCircle = nil
		end
	end

	--// Loop de atualiza√ß√£o de visuais (chamado por RenderStepped) //--
	local function updateVisuals()
		local CONFIG = Core.CONFIG
		local player = Core.Services.Players.LocalPlayer

		for _, npc in ipairs(CONFIG.VISUAL_NPC_FOLDER:GetChildren()) do
			if npc:IsA("Model") and npc ~= player.Character then
				local hum     = npc:FindFirstChild("Humanoid")
				local npcRoot = npc:FindFirstChild("HumanoidRootPart")

				if hum and npcRoot and hum.Health > 0 then
					if State.espEnabled         then createESP(npc)       else removeESP(npc)       end
					if State.tracersEnabled      then createTracer(npc)    else removeTracer(npc)    end
					if State.healthBarsEnabled   then
						createHealthBar(npc)
						updateHealthBar(npc)
					else
						removeHealthBar(npc)
					end
				else
					removeESP(npc)
					removeTracer(npc)
					removeHealthBar(npc)
				end
			end
		end

		updateTracers()
	end

	return {
		-- NPC ESP
		createESP      = createESP,
		removeESP      = removeESP,
		clearAllESP    = clearAllESP,
		-- Tracers
		createTracer   = createTracer,
		updateTracers  = updateTracers,
		removeTracer   = removeTracer,
		clearAllTracers= clearAllTracers,
		-- Health Bars
		createHealthBar  = createHealthBar,
		updateHealthBar  = updateHealthBar,
		removeHealthBar  = removeHealthBar,
		clearAllHealthBars = clearAllHealthBars,
		-- Player ESP
		updatePlayerESP  = updatePlayerESP,
		-- FOV
		createFOVCircle  = createFOVCircle,
		updateFOVCircle  = updateFOVCircle,
		removeFOVCircle  = removeFOVCircle,
		-- Update geral
		updateVisuals    = updateVisuals,
	}
end)()

--//====================================================--
--//                 COMBAT SYSTEM                      --
--//====================================================--

local Combat = (function()
	local State  = Core.State
	local CONFIG = Core.CONFIG
	local Cache  = Core.Cache

	--// Lock On Target //--
	local function lockOnLoop()
		if not State.lockOnEnabled then return end
		local camera = workspace.CurrentCamera
		local target = State.lockedTarget

		if State.autofarmEnabled and State.lockedNPC then
			target = State.lockedNPC
		end

		if not target or not target.Parent then
			target = NPCCache.findClosest()
			State.lockedTarget = target
		end

		if target then
			local npcRoot = target:FindFirstChild("HumanoidRootPart")
			if npcRoot then
				camera.CFrame = Cache.CFrame_new(camera.CFrame.Position, npcRoot.Position)
			end
		end
	end

	--// Auto Farm (Behind / Above) //--
	local function autofarmLoop()
		if not State.autofarmEnabled then return end
		local root = Utils.getCharComponents()
		if not root then return end

		if not NPCCache.isValid(State.lockedNPC) then
			State.lockedNPC = NPCCache.findClosest()
		end

		local npc = State.lockedNPC
		if not npc then return end

		local npcRoot = npc:FindFirstChild("HumanoidRootPart")
		if not npcRoot then
			State.lockedNPC = nil
			return
		end

		root.AssemblyLinearVelocity  = Cache.Vector3_zero
		root.AssemblyAngularVelocity = Cache.Vector3_zero

		if State.autofarmMode == "Above" then
			-- Posi√ß√£o fixa acima do NPC, olhando para baixo
			local targetPos = npcRoot.Position + Cache.Vector3_new(0, State.autofarmDistance, 0)
			root.CFrame = CFrame.new(targetPos) * CFrame.Angles(math.rad(-90), 0, 0)
		else
			-- Atr√°s do NPC na dire√ß√£o do LookVector
			local backVec    = -npcRoot.CFrame.LookVector * State.autofarmDistance
			local upVec      = Cache.Vector3_new(0, CONFIG.HEIGHT_OFFSET, 0)
			local targetPos  = npcRoot.Position + backVec + upVec
			root.CFrame = Cache.CFrame_new(targetPos, npcRoot.Position)
		end
	end

	--// M1 Auto Click //--
	local function simulateMouseClick()
		local virtualInput = game:GetService("VirtualInputManager")
		virtualInput:SendMouseButtonEvent(0, 0, 0, true, game, 0)
		task.wait(0.01)
		virtualInput:SendMouseButtonEvent(0, 0, 0, false, game, 0)
	end

	local function m1MacroLoop()
		if not State.m1MacroEnabled then return end
		local now = tick()
		if now - State.lastM1Click >= State.m1ClickDelay then
			pcall(simulateMouseClick)
			State.lastM1Click = now
		end
	end

	--// Speed Boost //--
	local function speedLoop()
		if not State.speedEnabled then return end
		local root, hum = Utils.getCharComponents()
		if root and hum then
			local moveDir = hum.MoveDirection
			if moveDir.Magnitude > 0 then
				local curY = root.AssemblyLinearVelocity.Y
				root.AssemblyLinearVelocity = (moveDir.Unit * State.speedValue) + Cache.Vector3_new(0, curY, 0)
			end
		end
	end

	return {
		lockOnLoop   = lockOnLoop,
		autofarmLoop = autofarmLoop,
		m1MacroLoop  = m1MacroLoop,
		speedLoop    = speedLoop,
	}
end)()

--//====================================================--
--//               MOVEMENT SYSTEM                      --
--//====================================================--

local Movement = (function()
	local player = Core.Services.Players.LocalPlayer

	--// No Clip //--
	local function enableNoClip()
		local char = player.Character
		if not char then return end
		for _, part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end

	local function disableNoClip()
		local char = player.Character
		if not char then return end
		for _, part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				part.CanCollide = true
			end
		end
	end

	return {
		enableNoClip  = enableNoClip,
		disableNoClip = disableNoClip,
	}
end)()

--//====================================================--
--//               TELEPORT SYSTEM                      --
--//====================================================--

local Teleport = (function()
	local State    = Core.State
	local CONFIG   = Core.CONFIG
	local Cache    = Core.Cache
	local Services = Core.Services

	--// Teleporte suave (anti-kick) com divis√£o por chunks //--
	local function ultraSmoothTeleport(targetPosition)
		if State.isTeleporting then return false end
		local root = Utils.getCharComponents()
		if not root then return false end

		State.isTeleporting = true
		local startPos = root.Position
		local distance = (targetPosition - startPos).Magnitude

		-- Teleporte direto para dist√¢ncias pequenas
		if distance < 10 then
			root.CFrame = Cache.CFrame_new(targetPosition)
			State.isTeleporting = false
			return true
		end

		local travelTime = distance / CONFIG.TELEPORT_SPEED

		if distance > CONFIG.MAX_TELEPORT_DISTANCE then
			-- Divide em chunks para evitar anti-cheat
			local direction = (targetPosition - startPos).Unit
			local numChunks = math.ceil(distance / CONFIG.MAX_TELEPORT_DISTANCE)

			for i = 1, numChunks do
				if not State.isTeleporting then break end
				local chunkTarget = (i == numChunks)
					and targetPosition
					or  (startPos + direction * CONFIG.MAX_TELEPORT_DISTANCE * i)

				local chunkTime = (chunkTarget - root.Position).Magnitude / CONFIG.TELEPORT_SPEED
				local tween = Services.TweenService:Create(
					root,
					TweenInfo.new(chunkTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
					{ CFrame = Cache.CFrame_new(chunkTarget) }
				)
				tween:Play()
				tween.Completed:Wait()
				task.wait(0.1)
			end
		else
			local tween = Services.TweenService:Create(
				root,
				TweenInfo.new(travelTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
				{ CFrame = Cache.CFrame_new(targetPosition) }
			)
			tween:Play()
			tween.Completed:Wait()
		end

		State.isTeleporting = false
		return true
	end

	--// Teleporta para NPC pelo nome //--
	local function safeTeleportToNPC(npcName)
		local root = Utils.getCharComponents()
		if not root then return false, "Character not found" end

		for _, npc in ipairs(CONFIG.TELEPORT_NPC_FOLDER:GetChildren()) do
			if npc.Name == npcName and npc:IsA("Model") then
				local npcRoot = npc:FindFirstChild("HumanoidRootPart")
				if npcRoot then
					task.spawn(function()
						ultraSmoothTeleport(npcRoot.Position + Cache.Vector3_new(0, 2, 5))
					end)
					return true, "Teleporting..."
				end
			end
		end

		return false, "NPC not found"
	end

	--// Lista NPCs dispon√≠veis para teleporte //--
	local function getNPCList()
		local list = {}
		for _, npc in ipairs(CONFIG.TELEPORT_NPC_FOLDER:GetChildren()) do
			if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
				if not table.find(list, npc.Name) then
					table.insert(list, npc.Name)
				end
			end
		end
		table.sort(list)
		return list
	end

	return {
		ultraSmoothTeleport = ultraSmoothTeleport,
		safeTeleportToNPC   = safeTeleportToNPC,
		getNPCList          = getNPCList,
	}
end)()

--//====================================================--
--//                   GUI SYSTEM                       --
--//====================================================--

local GUI = (function()
	local State    = Core.State
	local CONFIG   = Core.CONFIG
	local Cache    = Core.Cache
	local Services = Core.Services

	-- Refer√™ncia global da screenGui para cleanup
	local screenGui, mainFrame

	--// Componentes base de GUI //--

	-- Cria cabe√ßalho de se√ß√£o
	local function createSectionHeader(parent, text)
		local frame = Instance.new("Frame")
		frame.Size              = Cache.UDim2_new(1, 0, 0, 30)
		frame.BackgroundColor3  = Cache.Color3_fromRGB(18, 18, 25)
		frame.BorderSizePixel   = 0
		frame.Parent            = parent

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent       = frame

		local label             = Instance.new("TextLabel")
		label.Size              = Cache.UDim2_new(1, -15, 1, 0)
		label.Position          = Cache.UDim2_new(0, 10, 0, 0)
		label.BackgroundTransparency = 1
		label.Text              = text
		label.Font              = Enum.Font.GothamBold
		label.TextSize          = 12
		label.TextColor3        = Cache.Color3_fromRGB(180, 180, 200)
		label.TextXAlignment    = Enum.TextXAlignment.Left
		label.Parent            = frame

		local icon = Instance.new("TextLabel")
		icon.Size               = Cache.UDim2_new(0, 15, 1, 0)
		icon.BackgroundTransparency = 1
		icon.Text               = "‚óá"
		icon.Font               = Enum.Font.GothamBold
		icon.TextSize           = 10
		icon.TextColor3         = Cache.Color3_fromRGB(100, 180, 255)
		icon.TextXAlignment     = Enum.TextXAlignment.Left
		icon.Parent             = label

		return frame
	end

	-- Cria toggle com label e descri√ß√£o opcional
	local function createToggle(parent, labelText, descText, defaultState)
		local container             = Instance.new("Frame")
		container.Size              = Cache.UDim2_new(1, 0, 0, descText and 55 or 40)
		container.BackgroundColor3  = Cache.Color3_fromRGB(18, 18, 25)
		container.BorderSizePixel   = 0
		container.Parent            = parent

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent       = container

		local label             = Instance.new("TextLabel")
		label.Size              = Cache.UDim2_new(0.7, -10, 0, 20)
		label.Position          = Cache.UDim2_new(0, 10, 0, descText and 8 or 10)
		label.BackgroundTransparency = 1
		label.Text              = labelText
		label.Font              = Enum.Font.Gotham
		label.TextSize          = 12
		label.TextColor3        = Cache.Color3_white
		label.TextXAlignment    = Enum.TextXAlignment.Left
		label.Parent            = container

		if descText then
			local desc              = Instance.new("TextLabel")
			desc.Size               = Cache.UDim2_new(1, -20, 0, 18)
			desc.Position           = Cache.UDim2_new(0, 10, 0, 28)
			desc.BackgroundTransparency = 1
			desc.Text               = descText
			desc.Font               = Enum.Font.Gotham
			desc.TextSize           = 9
			desc.TextColor3         = Cache.Color3_fromRGB(120, 120, 140)
			desc.TextXAlignment     = Enum.TextXAlignment.Left
			desc.TextWrapped        = true
			desc.Parent             = container
		end

		local toggleBg              = Instance.new("Frame")
		toggleBg.Size               = Cache.UDim2_new(0, 38, 0, 20)
		toggleBg.Position           = Cache.UDim2_new(1, -45, 0, 10)
		toggleBg.BackgroundColor3   = defaultState
			and Cache.Color3_fromRGB(100, 180, 255)
			or  Cache.Color3_fromRGB(40, 40, 55)
		toggleBg.BorderSizePixel    = 0
		toggleBg.Parent             = container

		local toggleBgCorner = Instance.new("UICorner")
		toggleBgCorner.CornerRadius = UDim.new(1, 0)
		toggleBgCorner.Parent = toggleBg

		local toggleCircle          = Instance.new("Frame")
		toggleCircle.Size           = Cache.UDim2_new(0, 16, 0, 16)
		toggleCircle.Position       = defaultState
			and Cache.UDim2_new(1, -18, 0.5, -8)
			or  Cache.UDim2_new(0, 2, 0.5, -8)
		toggleCircle.BackgroundColor3 = Cache.Color3_white
		toggleCircle.BorderSizePixel  = 0
		toggleCircle.Parent           = toggleBg

		local circleCorner = Instance.new("UICorner")
		circleCorner.CornerRadius = UDim.new(1, 0)
		circleCorner.Parent = toggleCircle

		local toggleBtn             = Instance.new("TextButton")
		toggleBtn.Size              = Cache.UDim2_new(1, 0, 1, 0)
		toggleBtn.BackgroundTransparency = 1
		toggleBtn.Text              = ""
		toggleBtn.Parent            = toggleBg

		-- Retorna: container, bot√£o clic√°vel, background do toggle, c√≠rculo animado
		return container, toggleBtn, toggleBg, toggleCircle
	end

	-- Cria slider com label, min, max e valor padr√£o
	local function createSlider(parent, labelText, minVal, maxVal, defaultVal)
		local container             = Instance.new("Frame")
		container.Size              = Cache.UDim2_new(1, 0, 0, 50)
		container.BackgroundColor3  = Cache.Color3_fromRGB(18, 18, 25)
		container.BorderSizePixel   = 0
		container.Parent            = parent

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent       = container

		local label             = Instance.new("TextLabel")
		label.Size              = Cache.UDim2_new(0.6, 0, 0, 18)
		label.Position          = Cache.UDim2_new(0, 10, 0, 8)
		label.BackgroundTransparency = 1
		label.Text              = labelText
		label.Font              = Enum.Font.Gotham
		label.TextSize          = 11
		label.TextColor3        = Cache.Color3_white
		label.TextXAlignment    = Enum.TextXAlignment.Left
		label.Parent            = container

		local valueLabel            = Instance.new("TextLabel")
		valueLabel.Size             = Cache.UDim2_new(0, 50, 0, 18)
		valueLabel.Position         = Cache.UDim2_new(1, -55, 0, 8)
		valueLabel.BackgroundTransparency = 1
		valueLabel.Text             = tostring(defaultVal)
		valueLabel.Font             = Enum.Font.GothamBold
		valueLabel.TextSize         = 11
		valueLabel.TextColor3       = Cache.Color3_fromRGB(100, 180, 255)
		valueLabel.TextXAlignment   = Enum.TextXAlignment.Right
		valueLabel.Parent           = container

		local sliderBg              = Instance.new("Frame")
		sliderBg.Size               = Cache.UDim2_new(1, -20, 0, 4)
		sliderBg.Position           = Cache.UDim2_new(0, 10, 1, -15)
		sliderBg.BackgroundColor3   = Cache.Color3_fromRGB(30, 30, 42)
		sliderBg.BorderSizePixel    = 0
		sliderBg.Parent             = container

		local sliderBgCorner = Instance.new("UICorner")
		sliderBgCorner.CornerRadius = UDim.new(1, 0)
		sliderBgCorner.Parent = sliderBg

		local sliderFill            = Instance.new("Frame")
		sliderFill.Size             = Cache.UDim2_new((defaultVal - minVal) / (maxVal - minVal), 0, 1, 0)
		sliderFill.BackgroundColor3 = Cache.Color3_fromRGB(100, 180, 255)
		sliderFill.BorderSizePixel  = 0
		sliderFill.Parent           = sliderBg

		local fillCorner = Instance.new("UICorner")
		fillCorner.CornerRadius = UDim.new(1, 0)
		fillCorner.Parent = sliderFill

		local sliderBtn             = Instance.new("TextButton")
		sliderBtn.Size              = Cache.UDim2_new(1, 0, 1, 10)
		sliderBtn.Position          = Cache.UDim2_new(0, 0, 0, -5)
		sliderBtn.BackgroundTransparency = 1
		sliderBtn.Text              = ""
		sliderBtn.Parent            = sliderBg

		-- Retorna: container, bot√£o, fill, label de valor, min, max
		return container, sliderBtn, sliderFill, valueLabel, minVal, maxVal
	end

	-- Cria bot√£o simples
	local function createButton(parent, text, color)
		local btn               = Instance.new("TextButton")
		btn.Size                = Cache.UDim2_new(1, 0, 0, 35)
		btn.BackgroundColor3    = color or Cache.Color3_fromRGB(100, 180, 255)
		btn.Text                = text
		btn.Font                = Enum.Font.GothamBold
		btn.TextSize            = 12
		btn.TextColor3          = Cache.Color3_white
		btn.BorderSizePixel     = 0
		btn.AutoButtonColor     = false
		btn.Parent              = parent

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent = btn

		return btn
	end

	-- Cria p√°gina (ScrollingFrame)
	local function createPage(name, parent)
		local page = Instance.new("ScrollingFrame")
		page.Name                   = name
		page.Size                   = Cache.UDim2_new(1, -5, 1, 0)
		page.BackgroundTransparency = 1
		page.BorderSizePixel        = 0
		page.ScrollBarThickness     = 3
		page.ScrollBarImageColor3   = Cache.Color3_fromRGB(80, 80, 100)
		page.CanvasSize             = Cache.UDim2_new(0, 0, 0, 0)
		page.AutomaticCanvasSize    = Enum.AutomaticSize.Y
		page.Visible                = false
		page.Parent                 = parent

		local layout = Instance.new("UIListLayout")
		layout.Padding   = UDim.new(0, 8)
		layout.SortOrder = Enum.SortOrder.LayoutOrder
		layout.Parent    = page

		local padding = Instance.new("UIPadding")
		padding.PaddingRight = UDim.new(0, 5)
		padding.Parent = page

		return page
	end

	-- Cria bot√£o da sidebar
	local function createSidebarBtn(parent, icon, name)
		local btn               = Instance.new("TextButton")
		btn.Name                = name
		btn.Size                = Cache.UDim2_new(0, 35, 0, 35)
		btn.BackgroundColor3    = Cache.Color3_fromRGB(22, 22, 30)
		btn.Text                = icon
		btn.Font                = Enum.Font.GothamBold
		btn.TextSize            = 16
		btn.TextColor3          = Cache.Color3_fromRGB(120, 120, 140)
		btn.BorderSizePixel     = 0
		btn.AutoButtonColor     = false
		btn.Parent              = parent

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent = btn

		return btn
	end

	--// Tabela de fun√ß√µes de toggle (conectada com a GUI) //--
	-- Separada para ser acessada por Input e GUI
	local ToggleFunctions = {}

	--// Constru√ß√£o da GUI principal //--
	local function build()
		-- Remove GUI antiga se existir
		pcall(function()
			Core.Services.CoreGui:FindFirstChild(CONFIG.GUI_NAME):Destroy()
		end)

		-- ScreenGui raiz
		screenGui = Instance.new("ScreenGui")
		screenGui.Name           = CONFIG.GUI_NAME
		screenGui.ResetOnSpawn   = false
		screenGui.IgnoreGuiInset = true
		screenGui.Parent         = Services.CoreGui

		-- Frame principal
		mainFrame = Instance.new("Frame")
		mainFrame.Name              = "MainFrame"
		mainFrame.Size              = Cache.UDim2_new(0, 320, 0, 450)
		mainFrame.Position          = Cache.UDim2_new(0, 20, 0.5, -225)
		mainFrame.BackgroundColor3  = Cache.Color3_fromRGB(13, 13, 18)
		mainFrame.BorderSizePixel   = 0
		mainFrame.Active            = true
		mainFrame.Draggable         = true
		mainFrame.Parent            = screenGui

		local mainCorner = Instance.new("UICorner")
		mainCorner.CornerRadius = UDim.new(0, 8)
		mainCorner.Parent = mainFrame

		local borderGradient = Instance.new("UIStroke")
		borderGradient.Color       = Cache.Color3_fromRGB(100, 100, 120)
		borderGradient.Thickness   = 1
		borderGradient.Transparency= 0.5
		borderGradient.Parent      = mainFrame

		--// Header //--
		local header = Instance.new("Frame")
		header.Name             = "Header"
		header.Size             = Cache.UDim2_new(1, 0, 0, 35)
		header.BackgroundColor3 = Cache.Color3_fromRGB(18, 18, 25)
		header.BorderSizePixel  = 0
		header.Parent           = mainFrame

		local headerCorner = Instance.new("UICorner")
		headerCorner.CornerRadius = UDim.new(0, 8)
		headerCorner.Parent = header

		local headerFill = Instance.new("Frame")
		headerFill.Size             = Cache.UDim2_new(1, 0, 0, 8)
		headerFill.Position         = Cache.UDim2_new(0, 0, 1, -8)
		headerFill.BackgroundColor3 = Cache.Color3_fromRGB(18, 18, 25)
		headerFill.BorderSizePixel  = 0
		headerFill.Parent           = header

		local titleContainer = Instance.new("Frame")
		titleContainer.Size             = Cache.UDim2_new(1, -80, 1, 0)
		titleContainer.Position         = Cache.UDim2_new(0, 10, 0, 0)
		titleContainer.BackgroundTransparency = 1
		titleContainer.Parent           = header

		local titleIcon = Instance.new("TextLabel")
		titleIcon.Size              = Cache.UDim2_new(0, 20, 1, 0)
		titleIcon.BackgroundTransparency = 1
		titleIcon.Text              = "‚ú¶"
		titleIcon.Font              = Enum.Font.GothamBold
		titleIcon.TextSize          = 16
		titleIcon.TextColor3        = Cache.Color3_fromRGB(100, 180, 255)
		titleIcon.TextXAlignment    = Enum.TextXAlignment.Left
		titleIcon.Parent            = titleContainer

		local titleLabel = Instance.new("TextLabel")
		titleLabel.Size             = Cache.UDim2_new(1, -25, 1, 0)
		titleLabel.Position         = Cache.UDim2_new(0, 25, 0, 0)
		titleLabel.BackgroundTransparency = 1
		titleLabel.Text             = "CYBER HUB"
		titleLabel.Font             = Enum.Font.GothamBold
		titleLabel.TextSize         = 13
		titleLabel.TextColor3       = Cache.Color3_white
		titleLabel.TextXAlignment   = Enum.TextXAlignment.Left
		titleLabel.Parent           = titleContainer

		local versionLabel = Instance.new("TextLabel")
		versionLabel.Size           = Cache.UDim2_new(0, 80, 1, 0)
		versionLabel.Position       = Cache.UDim2_new(1, -90, 0, 0)
		versionLabel.BackgroundTransparency = 1
		versionLabel.Text           = "4.3"
		versionLabel.Font           = Enum.Font.Gotham
		versionLabel.TextSize       = 11
		versionLabel.TextColor3     = Cache.Color3_fromRGB(120, 120, 140)
		versionLabel.TextXAlignment = Enum.TextXAlignment.Right
		versionLabel.Parent         = header

		local closeBtn              = Instance.new("TextButton")
		closeBtn.Size               = Cache.UDim2_new(0, 25, 0, 25)
		closeBtn.Position           = Cache.UDim2_new(1, -30, 0, 5)
		closeBtn.BackgroundColor3   = Cache.Color3_fromRGB(25, 25, 35)
		closeBtn.Text               = "√ó"
		closeBtn.Font               = Enum.Font.GothamBold
		closeBtn.TextSize           = 18
		closeBtn.TextColor3         = Cache.Color3_fromRGB(200, 200, 210)
		closeBtn.BorderSizePixel    = 0
		closeBtn.Parent             = header

		local closeBtnCorner = Instance.new("UICorner")
		closeBtnCorner.CornerRadius = UDim.new(0, 4)
		closeBtnCorner.Parent = closeBtn

		closeBtn.MouseButton1Click:Connect(function()
			screenGui:Destroy()
		end)

		--// Sidebar //--
		local sidebar = Instance.new("Frame")
		sidebar.Name            = "Sidebar"
		sidebar.Size            = Cache.UDim2_new(0, 45, 1, -40)
		sidebar.Position        = Cache.UDim2_new(0, 5, 0, 38)
		sidebar.BackgroundColor3= Cache.Color3_fromRGB(18, 18, 25)
		sidebar.BorderSizePixel = 0
		sidebar.Parent          = mainFrame

		local sidebarCorner = Instance.new("UICorner")
		sidebarCorner.CornerRadius = UDim.new(0, 6)
		sidebarCorner.Parent = sidebar

		local sidebarLayout = Instance.new("UIListLayout")
		sidebarLayout.Padding              = UDim.new(0, 5)
		sidebarLayout.HorizontalAlignment  = Enum.HorizontalAlignment.Center
		sidebarLayout.Parent               = sidebar

		local sidebarPadding = Instance.new("UIPadding")
		sidebarPadding.PaddingTop = UDim.new(0, 8)
		sidebarPadding.Parent = sidebar

		local combatBtn   = createSidebarBtn(sidebar, "‚öî", "CombatBtn")
		local visualBtn   = createSidebarBtn(sidebar, "üëÅ", "VisualBtn")
		local teleportBtn = createSidebarBtn(sidebar, "üìç", "TeleportBtn")
		local miscBtn     = createSidebarBtn(sidebar, "üîß", "MiscBtn")

		--// Content Area //--
		local contentArea = Instance.new("Frame")
		contentArea.Name                = "ContentArea"
		contentArea.Size                = Cache.UDim2_new(1, -60, 1, -40)
		contentArea.Position            = Cache.UDim2_new(0, 55, 0, 38)
		contentArea.BackgroundTransparency = 1
		contentArea.Parent              = mainFrame

		local combatPage   = createPage("CombatPage",   contentArea)
		local visualPage   = createPage("VisualPage",   contentArea)
		local teleportPage = createPage("TeleportPage", contentArea)
		local miscPage     = createPage("MiscPage",     contentArea)

		-- Troca de p√°gina ativa
		local allPages = {combatPage, visualPage, teleportPage, miscPage}
		local allBtns  = {combatBtn, visualBtn, teleportBtn, miscBtn}

		local function switchPage(targetPage, targetBtn)
			for _, p in ipairs(allPages) do p.Visible = false end
			for _, b in ipairs(allBtns) do
				b.BackgroundColor3 = Cache.Color3_fromRGB(22, 22, 30)
				b.TextColor3       = Cache.Color3_fromRGB(120, 120, 140)
			end
			targetPage.Visible       = true
			targetBtn.BackgroundColor3 = Cache.Color3_fromRGB(100, 180, 255)
			targetBtn.TextColor3       = Cache.Color3_white
		end

		combatBtn.MouseButton1Click:Connect(function()   switchPage(combatPage,   combatBtn) end)
		visualBtn.MouseButton1Click:Connect(function()   switchPage(visualPage,   visualBtn) end)
		teleportBtn.MouseButton1Click:Connect(function() switchPage(teleportPage, teleportBtn) end)
		miscBtn.MouseButton1Click:Connect(function()     switchPage(miscPage,     miscBtn) end)

		switchPage(combatPage, combatBtn)

		--//====================================================--
		--//                  COMBAT PAGE                       --
		--//====================================================--

		createSectionHeader(combatPage, "Auto Farm Settings")

		local _, autofarmToggle, autofarmBg, autofarmCircle = createToggle(
			combatPage, "Auto Farm", "Automatically farm the closest NPC", State.autofarmEnabled)

		-- Seletor de modo: Behind / Above
		local farmModeContainer = Instance.new("Frame")
		farmModeContainer.Name            = "FarmModeContainer"
		farmModeContainer.Size            = Cache.UDim2_new(1, 0, 0, 78)
		farmModeContainer.BackgroundColor3= Cache.Color3_fromRGB(18, 18, 25)
		farmModeContainer.BorderSizePixel = 0
		farmModeContainer.Parent          = combatPage

		local farmModeCorner = Instance.new("UICorner")
		farmModeCorner.CornerRadius = UDim.new(0, 6)
		farmModeCorner.Parent = farmModeContainer

		local farmModeLabel = Instance.new("TextLabel")
		farmModeLabel.Size              = Cache.UDim2_new(1, -20, 0, 18)
		farmModeLabel.Position          = Cache.UDim2_new(0, 10, 0, 6)
		farmModeLabel.BackgroundTransparency = 1
		farmModeLabel.Text              = "Farm Position"
		farmModeLabel.Font              = Enum.Font.GothamBold
		farmModeLabel.TextSize          = 11
		farmModeLabel.TextColor3        = Cache.Color3_fromRGB(180, 180, 200)
		farmModeLabel.TextXAlignment    = Enum.TextXAlignment.Left
		farmModeLabel.Parent            = farmModeContainer

		local farmModeButtonsFrame = Instance.new("Frame")
		farmModeButtonsFrame.Name   = "FarmPositionButtons"
		farmModeButtonsFrame.Size   = Cache.UDim2_new(1, -20, 0, 44)
		farmModeButtonsFrame.Position = Cache.UDim2_new(0, 10, 0, 28)
		farmModeButtonsFrame.BackgroundTransparency = 1
		farmModeButtonsFrame.Parent = farmModeContainer

		local farmBtnsLayout = Instance.new("UIListLayout")
		farmBtnsLayout.FillDirection       = Enum.FillDirection.Horizontal
		farmBtnsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
		farmBtnsLayout.VerticalAlignment   = Enum.VerticalAlignment.Center
		farmBtnsLayout.Padding             = UDim.new(0, 8)
		farmBtnsLayout.SortOrder           = Enum.SortOrder.LayoutOrder
		farmBtnsLayout.Parent              = farmModeButtonsFrame

		local function makeFarmModeBtn(name, layoutOrder)
			local btn = Instance.new("TextButton")
			btn.Name              = "Option_" .. name
			btn.LayoutOrder       = layoutOrder
			btn.Size              = Cache.UDim2_new(0, 130, 0, 28)
			btn.BackgroundColor3  = Cache.Color3_fromRGB(40, 40, 55)
			btn.Text              = name
			btn.Font              = Enum.Font.GothamBold
			btn.TextSize          = 11
			btn.TextColor3        = Cache.Color3_fromRGB(180, 180, 200)
			btn.BorderSizePixel   = 0
			btn.AutoButtonColor   = false
			btn.Parent            = farmModeButtonsFrame
			local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0,6); c.Parent = btn
			return btn
		end

		local farmModeBehindBtn = makeFarmModeBtn("Behind", 1)
		local farmModeAboveBtn  = makeFarmModeBtn("Above",  2)

		local function updateFarmPositionVisuals()
			local isBehind = (State.autofarmMode == "Behind")
			farmModeBehindBtn.BackgroundColor3 = isBehind and Cache.Color3_fromRGB(100,180,255) or Cache.Color3_fromRGB(40,40,55)
			farmModeBehindBtn.TextColor3       = isBehind and Cache.Color3_white or Cache.Color3_fromRGB(180,180,200)
			farmModeAboveBtn.BackgroundColor3  = isBehind and Cache.Color3_fromRGB(40,40,55) or Cache.Color3_fromRGB(100,180,255)
			farmModeAboveBtn.TextColor3        = isBehind and Cache.Color3_fromRGB(180,180,200) or Cache.Color3_white
		end

		farmModeBehindBtn.MouseButton1Click:Connect(function()
			State.autofarmMode = "Behind"; updateFarmPositionVisuals()
		end)
		farmModeAboveBtn.MouseButton1Click:Connect(function()
			State.autofarmMode = "Above"; updateFarmPositionVisuals()
		end)
		farmModeBehindBtn.MouseEnter:Connect(function()
			if State.autofarmMode ~= "Behind" then
				farmModeBehindBtn.BackgroundColor3 = Cache.Color3_fromRGB(55,55,70)
			end
		end)
		farmModeBehindBtn.MouseLeave:Connect(updateFarmPositionVisuals)
		farmModeAboveBtn.MouseEnter:Connect(function()
			if State.autofarmMode ~= "Above" then
				farmModeAboveBtn.BackgroundColor3 = Cache.Color3_fromRGB(55,55,70)
			end
		end)
		farmModeAboveBtn.MouseLeave:Connect(updateFarmPositionVisuals)
		updateFarmPositionVisuals()

		-- Slider: dist√¢ncia do autofarm
		local _, autofarmDistSliderBtn, autofarmDistFill, autofarmDistLabel, autofarmDistMin, autofarmDistMax = createSlider(
			combatPage, "Autofarm Distance", 1, 25, State.autofarmDistance)

		local _, lockOnToggle, lockOnBg, lockOnCircle = createToggle(
			combatPage, "Lock On Target", "Camera locks onto nearest enemy", State.lockOnEnabled)

		local _, m1Toggle, m1Bg, m1Circle = createToggle(
			combatPage, "M1 Auto Click (F2)", "Automatically click M1 button", State.m1MacroEnabled)

		local _, m1SliderBtn, m1SliderFill, m1ValueLabel, m1Min, m1Max = createSlider(
			combatPage, "M1 Click Delay", 0.05, 1, State.m1ClickDelay)

		createSectionHeader(combatPage, "Movement Settings")

		local _, speedToggle, speedBg, speedCircle = createToggle(
			combatPage, "Speed Boost", "Increase movement speed", State.speedEnabled)

		local _, speedSliderBtn, speedSliderFill, speedValueLabel, speedMin, speedMax = createSlider(
			combatPage, "Speed Value", 50, 300, State.speedValue)

		local _, jumpToggle, jumpBg, jumpCircle = createToggle(
			combatPage, "Infinite Jump", "Jump infinitely without limit", State.infiniteJumpEnabled)

		--//====================================================--
		--//                  VISUAL PAGE                       --
		--//====================================================--

		createSectionHeader(visualPage, "NPC Visual Features")

		local _, espToggle, espBg, espCircle = createToggle(
			visualPage, "ESP Highlights", "See NPCs through walls", State.espEnabled)

		local _, tracersToggle, tracersBg, tracersCircle = createToggle(
			visualPage, "Tracers", "Lines pointing to NPCs", State.tracersEnabled)

		local _, healthBarsToggle, healthBarsBg, healthBarsCircle = createToggle(
			visualPage, "Health Bars", "Display NPC health bars", State.healthBarsEnabled)

		createSectionHeader(visualPage, "Player Visual Features")

		local _, playerESPToggle, playerESPBg, playerESPCircle = createToggle(
			visualPage, "Player ESP", "See other players through walls", State.playerESPEnabled)

		local _, fovToggle, fovBg, fovToggleCircle = createToggle(
			visualPage, "FOV Circle", "Display field of view circle", State.fovEnabled)

		--//====================================================--
		--//                TELEPORT PAGE                       --
		--//====================================================--

		createSectionHeader(teleportPage, "Safe Teleport System")

		local tpInfoContainer = Instance.new("Frame")
		tpInfoContainer.Size              = Cache.UDim2_new(1, 0, 0, 60)
		tpInfoContainer.BackgroundColor3  = Cache.Color3_fromRGB(100, 180, 255)
		tpInfoContainer.BackgroundTransparency = 0.9
		tpInfoContainer.BorderSizePixel   = 0
		tpInfoContainer.Parent            = teleportPage

		local tpInfoCorner = Instance.new("UICorner")
		tpInfoCorner.CornerRadius = UDim.new(0, 6)
		tpInfoCorner.Parent = tpInfoContainer

		local tpInfoLabel = Instance.new("TextLabel")
		tpInfoLabel.Size              = Cache.UDim2_new(1, -20, 1, 0)
		tpInfoLabel.Position          = Cache.UDim2_new(0, 10, 0, 0)
		tpInfoLabel.BackgroundTransparency = 1
		tpInfoLabel.Text              = "üìç Ultra Smooth Teleport\nAnti-kick protection for long distances\nClick any NPC to teleport safely"
		tpInfoLabel.Font              = Enum.Font.Gotham
		tpInfoLabel.TextSize          = 10
		tpInfoLabel.TextColor3        = Cache.Color3_white
		tpInfoLabel.TextXAlignment    = Enum.TextXAlignment.Left
		tpInfoLabel.TextWrapped       = true
		tpInfoLabel.Parent            = tpInfoContainer

		local refreshNPCBtn = createButton(teleportPage, "üîÑ Refresh NPC List", Cache.Color3_fromRGB(80, 200, 120))

		local npcListContainer = Instance.new("Frame")
		npcListContainer.Name              = "NPCListContainer"
		npcListContainer.Size              = Cache.UDim2_new(1, 0, 0, 0)
		npcListContainer.AutomaticSize     = Enum.AutomaticSize.Y
		npcListContainer.BackgroundTransparency = 1
		npcListContainer.Parent            = teleportPage

		local npcListLayout = Instance.new("UIListLayout")
		npcListLayout.Padding   = UDim.new(0, 5)
		npcListLayout.SortOrder = Enum.SortOrder.LayoutOrder
		npcListLayout.Parent    = npcListContainer

		local function populateNPCList()
			for _, child in ipairs(npcListContainer:GetChildren()) do
				if child:IsA("TextButton") then child:Destroy() end
			end

			local npcList = Teleport.getNPCList()
			State.teleportNPCList = npcList

			for _, npcName in ipairs(npcList) do
				local npcBtn              = Instance.new("TextButton")
				npcBtn.Size               = Cache.UDim2_new(1, 0, 0, 32)
				npcBtn.BackgroundColor3   = Cache.Color3_fromRGB(18, 18, 25)
				npcBtn.Text               = "   üìå " .. npcName
				npcBtn.Font               = Enum.Font.Gotham
				npcBtn.TextSize           = 11
				npcBtn.TextColor3         = Cache.Color3_white
				npcBtn.TextXAlignment     = Enum.TextXAlignment.Left
				npcBtn.BorderSizePixel    = 0
				npcBtn.AutoButtonColor    = false
				npcBtn.Parent             = npcListContainer

				local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0,6); c.Parent = npcBtn

				npcBtn.MouseEnter:Connect(function()
					npcBtn.BackgroundColor3 = Cache.Color3_fromRGB(25, 25, 35)
				end)
				npcBtn.MouseLeave:Connect(function()
					npcBtn.BackgroundColor3 = Cache.Color3_fromRGB(18, 18, 25)
				end)
				npcBtn.MouseButton1Click:Connect(function()
					local success = Teleport.safeTeleportToNPC(npcName)
					npcBtn.BackgroundColor3 = success
						and Cache.Color3_fromRGB(80, 200, 120)
						or  Cache.Color3_fromRGB(200, 50, 50)
					task.wait(0.5)
					npcBtn.BackgroundColor3 = Cache.Color3_fromRGB(18, 18, 25)
				end)
			end
		end

		refreshNPCBtn.MouseButton1Click:Connect(populateNPCList)
		task.spawn(function() task.wait(1); populateNPCList() end)

		--//====================================================--
		--//                   MISC PAGE                        --
		--//====================================================--

		createSectionHeader(miscPage, "Misc Features")

		local _, noClipToggle, noClipBg, noClipCircle = createToggle(
			miscPage, "No Clip", "Walk through walls", State.noClipEnabled)

		--//====================================================--
		--//              TOGGLE FUNCTIONS (BINDINGS)           --
		--//====================================================--

		-- Autofarm
		ToggleFunctions.autofarm = function(enabled)
			State.autofarmEnabled = enabled
			Utils.animateToggle(autofarmBg, autofarmCircle, enabled)
			if enabled then
				Utils.disconnectConnection("autofarm")
				State.connections.autofarm = Services.RunService.Heartbeat:Connect(Combat.autofarmLoop)
			else
				Utils.disconnectConnection("autofarm")
				State.lockedNPC = nil
			end
		end
		autofarmToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.autofarm(not State.autofarmEnabled)
		end)

		-- Lock On
		ToggleFunctions.lockOn = function(enabled)
			State.lockOnEnabled = enabled
			Utils.animateToggle(lockOnBg, lockOnCircle, enabled)
			if enabled then
				Utils.disconnectConnection("lockOn")
				State.connections.lockOn = Services.RunService.RenderStepped:Connect(Combat.lockOnLoop)
			else
				Utils.disconnectConnection("lockOn")
				State.lockedTarget = nil
			end
		end
		lockOnToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.lockOn(not State.lockOnEnabled)
		end)

		-- M1 Macro
		ToggleFunctions.m1Macro = function(enabled)
			State.m1MacroEnabled = enabled
			Utils.animateToggle(m1Bg, m1Circle, enabled)
			if enabled then
				Utils.disconnectConnection("m1macro")
				State.connections.m1macro = Services.RunService.Heartbeat:Connect(Combat.m1MacroLoop)
			else
				Utils.disconnectConnection("m1macro")
			end
		end
		m1Toggle.MouseButton1Click:Connect(function()
			ToggleFunctions.m1Macro(not State.m1MacroEnabled)
		end)

		-- Speed
		ToggleFunctions.speed = function(enabled)
			State.speedEnabled = enabled
			Utils.animateToggle(speedBg, speedCircle, enabled)
			if enabled then
				Utils.disconnectConnection("speed")
				State.connections.speed = Services.RunService.Heartbeat:Connect(Combat.speedLoop)
			else
				Utils.disconnectConnection("speed")
			end
		end
		speedToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.speed(not State.speedEnabled)
		end)

		-- Infinite Jump
		ToggleFunctions.infiniteJump = function(enabled)
			State.infiniteJumpEnabled = enabled
			Utils.animateToggle(jumpBg, jumpCircle, enabled)
		end
		jumpToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.infiniteJump(not State.infiniteJumpEnabled)
		end)

		-- No Clip
		ToggleFunctions.noClip = function(enabled)
			State.noClipEnabled = enabled
			Utils.animateToggle(noClipBg, noClipCircle, enabled)
			if enabled then
				Movement.enableNoClip()
				Utils.disconnectConnection("noClip")
				State.connections.noClip = Services.RunService.Heartbeat:Connect(function()
					if State.noClipEnabled then Movement.enableNoClip() end
				end)
			else
				Movement.disableNoClip()
				Utils.disconnectConnection("noClip")
			end
		end
		noClipToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.noClip(not State.noClipEnabled)
		end)

		-- ESP
		ToggleFunctions.esp = function(enabled)
			State.espEnabled = enabled
			Utils.animateToggle(espBg, espCircle, enabled)
			if not enabled then ESP.clearAllESP() end
		end
		espToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.esp(not State.espEnabled)
		end)

		-- Tracers
		ToggleFunctions.tracers = function(enabled)
			State.tracersEnabled = enabled
			Utils.animateToggle(tracersBg, tracersCircle, enabled)
			if not enabled then ESP.clearAllTracers() end
		end
		tracersToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.tracers(not State.tracersEnabled)
		end)

		-- Health Bars
		ToggleFunctions.healthBars = function(enabled)
			State.healthBarsEnabled = enabled
			Utils.animateToggle(healthBarsBg, healthBarsCircle, enabled)
			if not enabled then ESP.clearAllHealthBars() end
		end
		healthBarsToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.healthBars(not State.healthBarsEnabled)
		end)

		-- Player ESP
		ToggleFunctions.playerESP = function(enabled)
			State.playerESPEnabled = enabled
			Utils.animateToggle(playerESPBg, playerESPCircle, enabled)
		end
		playerESPToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.playerESP(not State.playerESPEnabled)
		end)

		-- FOV Circle
		ToggleFunctions.fov = function(enabled)
			State.fovEnabled = enabled
			Utils.animateToggle(fovBg, fovToggleCircle, enabled)
			if enabled then ESP.createFOVCircle() else ESP.removeFOVCircle() end
		end
		fovToggle.MouseButton1Click:Connect(function()
			ToggleFunctions.fov(not State.fovEnabled)
		end)

		--// Sliders: l√≥gica de drag //--
		local m1Dragging            = false
		local autofarmDistDragging  = false
		local speedDragging         = false

		local function handleSlider(btn, fill, label, minV, maxV, precision, callback)
			local dragging = false
			btn.MouseButton1Down:Connect(function() dragging = true end)
			Services.UserInputService.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					dragging = false
				end
			end)
			Services.UserInputService.InputChanged:Connect(function(input)
				if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
					local sliderBg  = btn.Parent
					local mouseX    = Services.UserInputService:GetMouseLocation().X
					local pct       = math.clamp(
						(mouseX - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
					local value     = minV + pct * (maxV - minV)
					value           = math.floor(value * precision) / precision
					label.Text      = tostring(value)
					fill.Size       = Cache.UDim2_new(pct, 0, 1, 0)
					if callback then callback(value) end
				end
			end)
		end

		handleSlider(m1SliderBtn,           m1SliderFill,          m1ValueLabel,         m1Min,            m1Max,            100, function(v) State.m1ClickDelay   = v end)
		handleSlider(speedSliderBtn,        speedSliderFill,       speedValueLabel,      speedMin,         speedMax,         1,   function(v) State.speedValue      = v end)
		handleSlider(autofarmDistSliderBtn, autofarmDistFill,      autofarmDistLabel,    autofarmDistMin,  autofarmDistMax,  10,  function(v) State.autofarmDistance = v end)

		--// Cleanup ao destruir //--
		screenGui.Destroying:Connect(function()
			Utils.cleanAllConnections()
			ESP.clearAllESP()
			ESP.clearAllTracers()
			ESP.clearAllHealthBars()
			ESP.removeFOVCircle()
			for _, esp in pairs(State.playerESPObjects) do
				if esp then esp:Destroy() end
			end
		end)

		return { screenGui=screenGui, mainFrame=mainFrame, ToggleFunctions=ToggleFunctions }
	end

	return { build=build, getToggleFunctions=function() return ToggleFunctions end }
end)()

--//====================================================--
--//                 INPUT SYSTEM                       --
--//====================================================--
local Input = (function()
	local State    = Core.State
	local Services = Core.Services
	local player   = Services.Players.LocalPlayer

	local function init(mainFrame, ToggleFunctions)
		-- Infinite Jump
		Services.UserInputService.JumpRequest:Connect(function()
			if State.infiniteJumpEnabled then
				local _, hum = Utils.getCharComponents()
				if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
			end
		end)

		-- Hotkeys globais
		Services.UserInputService.InputBegan:Connect(function(input, processed)
			if processed then return end

			if input.KeyCode == Enum.KeyCode.F1 then
				State.guiVisible = not State.guiVisible
				mainFrame.Visible = State.guiVisible

			elseif input.KeyCode == Enum.KeyCode.F2 then
				ToggleFunctions.m1Macro(not State.m1MacroEnabled)

			elseif input.KeyCode == Enum.KeyCode.F3 then
				ToggleFunctions.autofarm(not State.autofarmEnabled)

			elseif input.KeyCode == Enum.KeyCode.KeypadOne then
				ToggleFunctions.speed(not State.speedEnabled)

			elseif input.KeyCode == Enum.KeyCode.KeypadTwo then
				ToggleFunctions.infiniteJump(not State.infiniteJumpEnabled)

			elseif input.KeyCode == Enum.KeyCode.KeypadZero then
				ToggleFunctions.esp(not State.espEnabled)

			elseif input.KeyCode == Enum.KeyCode.KeypadThree then
				ToggleFunctions.healthBars(not State.healthBarsEnabled)
			end
		end)

		-- Re-connect loops ap√≥s respawn
		player.CharacterAdded:Connect(function()
			Utils.invalidateCharCache()
			task.wait(0.3)

			if State.speedEnabled then
				Utils.disconnectConnection("speed")
				State.connections.speed = Services.RunService.Heartbeat:Connect(Combat.speedLoop)
			end
			if State.m1MacroEnabled then
				Utils.disconnectConnection("m1macro")
				State.connections.m1macro = Services.RunService.Heartbeat:Connect(Combat.m1MacroLoop)
			end
		end)
	end

	return { init=init }
end)()

--//====================================================--
--//              REGISTRO DE FEATURES                  --
--//====================================================--

Registry.register("ESP",      ESP)
Registry.register("Combat",   Combat)
Registry.register("Movement", Movement)
Registry.register("Teleport", Teleport)
Registry.register("NPCCache", NPCCache)

--//====================================================--
--//                  INICIALIZA√á√ÉO                     --
--//====================================================--

-- Verifica√ß√£o de player
local player = Core.Services.Players.LocalPlayer
if not player then return end

-- Constr√≥i a GUI e obt√©m refer√™ncias
local guiResult       = GUI.build()
local ToggleFunctions = guiResult.ToggleFunctions
local mainFrame       = guiResult.mainFrame

-- Inicia sistema de input com refer√™ncias da GUI
Input.init(mainFrame, ToggleFunctions)

-- Loop de renderiza√ß√£o (visuais + player ESP + FOV)
Core.State.connections.visualUpdate = Core.Services.RunService.RenderStepped:Connect(function()
	ESP.updateVisuals()
	ESP.updatePlayerESP()
	ESP.updateFOVCircle()
end)

--//====================================================--
--//                    STARTUP                         --
--//====================================================--

print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("        CYBER HUB - FFRE EDITION V4.3         ")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  ‚öîÔ∏è  Combat: Auto Farm (Behind/Above)")
print("  üéØ  Lock On | M1 Macro")
print("  üöÄ  Movement: Speed | Infinite Jump | No Clip")
print("  üëÅÔ∏è  Visual: ESP | Tracers | Health Bars")
print("  üìç  Teleport: Ultra Smooth (Anti-Kick)")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  F1  - Toggle GUI")
print("  F2  - Toggle M1 Macro")
print("  F3  - Toggle Autofarm")
print("  KP1 - Toggle Speed")
print("  KP2 - Toggle Infinite Jump")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

-- Exp√µe m√≥dulos para debug/extens√£o externa
return {
	Registry = Registry,
	Core     = Core,
	ESP      = ESP,
	Combat   = Combat,
	Movement = Movement,
	Teleport = Teleport,
}

end)() -- Fim do IIFE principal (CyberHub)
