-- ===== FFRE GUI V4 - NS HUB STYLE =====
-- Ultra Smooth Teleport (Anti-Kick) + Lock On Target + Workspace.LiveNPCS NPCs
-- Desktop Config Save + ESP + Tracers + Health Bars

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
if not player then return end

-- ===== CONFIG =====
local CONFIG = {
	BACK_DISTANCE = 3.5,
	HEIGHT_OFFSET = 2.5,
	MAX_DISTANCE = 60,
	NPC_SCAN_INTERVAL = 0.3,
	M1_CLICK_DELAY = 0.15,
	CHAR_CACHE_UPDATE = 0.5,
	GUI_NAME = "FFREStyledGui",
	CONFIGS_FOLDER = nil,
	DEFAULT_CONFIG_NAME = "Default",
	TELEPORT_SPEED = 150, -- Studs per second for smooth teleport
	MAX_TELEPORT_DISTANCE = 500 -- Max distance before chunking
}

-- ===== GET DESKTOP PATH =====
local function getDesktopPath()
	local desktopPath = nil
	
	pcall(function()
		if os.getenv then
			local userProfile = os.getenv("USERPROFILE")
			if userProfile then
				desktopPath = userProfile .. "\\Desktop\\"
			end
		end
	end)
	
	if not desktopPath then
		desktopPath = "C:\\Users\\" .. (os.getenv and os.getenv("USERNAME") or "User") .. "\\Desktop\\"
	end
	
	return desktopPath .. "FFRE_Configs\\"
end

CONFIG.CONFIGS_FOLDER = getDesktopPath()

-- ===== NPC FOLDER =====
-- MODIFICADO: Agora usa Workspace.LiveNPCS
local AliveFolder = workspace:WaitForChild("LiveNPCS")

-- ===== CACHE =====
local Vector3_new = Vector3.new
local Vector3_zero = Vector3.zero
local CFrame_new = CFrame.new
local UDim2_new = UDim2.new
local Color3_fromRGB = Color3.fromRGB
local Color3_white = Color3.new(1,1,1)
local Color3_black = Color3.new(0,0,0)

-- ===== STATE =====
local state = {
	autofarmEnabled = false,
	infiniteJumpEnabled = false,
	speedEnabled = false,
	m1MacroEnabled = false,
	espEnabled = false,
	tracersEnabled = false,
	healthBarsEnabled = false,
	lockOnEnabled = false,
	speedValue = 160,
	m1ClickDelay = CONFIG.M1_CLICK_DELAY,
	lockedNPC = nil,
	lockedTarget = nil,
	lastNPCScan = 0,
	npcCache = {},
	lastM1Click = 0,
	connections = {},
	guiVisible = true,
	guiToggleKey = Enum.KeyCode.F1,
	charCache = {
		root = nil,
		humanoid = nil,
		character = nil,
		lastUpdate = 0
	},
	lastSpeedApply = 0,
	currentPage = "combat",
	selectedConfig = nil,
	autoLoadConfig = nil,
	espObjects = {},
	tracerLines = {},
	healthBarObjects = {},
	isTeleporting = false
}

-- ===== CONFIGURATION SYSTEM =====
local ConfigSystem = {}

function ConfigSystem.ensureFolder()
	if not isfolder or not makefolder then 
		return false 
	end
	
	local success = pcall(function()
		if not isfolder(CONFIG.CONFIGS_FOLDER) then
			makefolder(CONFIG.CONFIGS_FOLDER)
		end
	end)
	
	return success
end

function ConfigSystem.getConfigList()
	if not ConfigSystem.ensureFolder() then return {} end
	if not listfiles then return {} end
	
	local configs = {}
	local success, files = pcall(function()
		return listfiles(CONFIG.CONFIGS_FOLDER)
	end)
	
	if not success then return {} end
	
	for _, file in ipairs(files) do
		local name = file:match("([^/\\]+)%.json$")
		if name then
			table.insert(configs, name)
		end
	end
	
	table.sort(configs)
	return configs
end

function ConfigSystem.saveConfig(name, settings)
	if not ConfigSystem.ensureFolder() then 
		return false, "File system not available" 
	end
	
	if not writefile then
		return false, "writefile not available"
	end
	
	local success, err = pcall(function()
		local fullPath = CONFIG.CONFIGS_FOLDER .. name .. ".json"
		local data = HttpService:JSONEncode(settings)
		writefile(fullPath, data)
	end)
	
	return success, err
end

function ConfigSystem.loadConfig(name)
	if not ConfigSystem.ensureFolder() then return nil end
	if not readfile or not isfile then return nil end
	
	local fullPath = CONFIG.CONFIGS_FOLDER .. name .. ".json"
	
	local fileExists = false
	pcall(function()
		fileExists = isfile(fullPath)
	end)
	
	if not fileExists then return nil end
	
	local success, data = pcall(function()
		local content = readfile(fullPath)
		return HttpService:JSONDecode(content)
	end)
	
	return success and data or nil
end

function ConfigSystem.deleteConfig(name)
	if not ConfigSystem.ensureFolder() then return false end
	if not delfile or not isfile then return false end
	
	local fullPath = CONFIG.CONFIGS_FOLDER .. name .. ".json"
	
	local success = pcall(function()
		if isfile(fullPath) then
			delfile(fullPath)
			return true
		end
	end)
	
	return success
end

function ConfigSystem.getCurrentSettings()
	return {
		speedValue = state.speedValue,
		m1ClickDelay = state.m1ClickDelay,
		guiToggleKey = state.guiToggleKey.Name,
		autofarmEnabled = state.autofarmEnabled,
		speedEnabled = state.speedEnabled,
		infiniteJumpEnabled = state.infiniteJumpEnabled,
		m1MacroEnabled = state.m1MacroEnabled,
		espEnabled = state.espEnabled,
		tracersEnabled = state.tracersEnabled,
		healthBarsEnabled = state.healthBarsEnabled,
		lockOnEnabled = state.lockOnEnabled,
		timestamp = os.date("%Y-%m-%d %H:%M:%S")
	}
end

function ConfigSystem.applySettings(settings)
	if not settings then return end
	
	state.speedValue = settings.speedValue or state.speedValue
	state.m1ClickDelay = settings.m1ClickDelay or state.m1ClickDelay
	
	task.spawn(function()
		task.wait(0.5)
		if toggleUpdateFunctions then
			if toggleUpdateFunctions.autofarm then
				toggleUpdateFunctions.autofarm(settings.autofarmEnabled == true)
			end
			if toggleUpdateFunctions.speed then
				toggleUpdateFunctions.speed(settings.speedEnabled == true)
			end
			if toggleUpdateFunctions.infiniteJump then
				toggleUpdateFunctions.infiniteJump(settings.infiniteJumpEnabled == true)
			end
			if toggleUpdateFunctions.m1Macro then
				toggleUpdateFunctions.m1Macro(settings.m1MacroEnabled == true)
			end
			if toggleUpdateFunctions.esp then
				toggleUpdateFunctions.esp(settings.espEnabled == true)
			end
			if toggleUpdateFunctions.tracers then
				toggleUpdateFunctions.tracers(settings.tracersEnabled == true)
			end
			if toggleUpdateFunctions.healthBars then
				toggleUpdateFunctions.healthBars(settings.healthBarsEnabled == true)
			end
			if toggleUpdateFunctions.lockOn then
				toggleUpdateFunctions.lockOn(settings.lockOnEnabled == true)
			end
		end
	end)
	
	local keyCode = settings.guiToggleKey and Enum.KeyCode[settings.guiToggleKey]
	if keyCode then
		state.guiToggleKey = keyCode
	end
	
	return true
end

-- ===== UTILS =====
local function disconnectConnection(name)
	if state.connections[name] then
		state.connections[name]:Disconnect()
		state.connections[name] = nil
	end
end

local function cleanAllConnections()
	for name, conn in pairs(state.connections) do
		if conn and conn.Connected then
			conn:Disconnect()
		end
	end
	table.clear(state.connections)
end

local function getCharComponents()
	local now = tick()
	if now - state.charCache.lastUpdate > CONFIG.CHAR_CACHE_UPDATE then
		local char = player.Character
		state.charCache.character = char
		state.charCache.root = char and char:FindFirstChild("HumanoidRootPart")
		state.charCache.humanoid = char and char:FindFirstChildOfClass("Humanoid")
		state.charCache.lastUpdate = now
	end
	return state.charCache.root, state.charCache.humanoid, state.charCache.character
end

local function invalidateCharCache()
	state.charCache.lastUpdate = 0
end

-- ===== NPC CACHE =====
local function updateNPCCache()
	table.clear(state.npcCache)
	local root, _, _ = getCharComponents()
	if not root then return end

	for _, npc in ipairs(AliveFolder:GetChildren()) do
		if npc:IsA("Model") and npc ~= player.Character then
			local hum = npc:FindFirstChild("Humanoid")
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			if hum and npcRoot and hum.Health > 0 then
				local dist = (root.Position - npcRoot.Position).Magnitude
				if dist <= CONFIG.MAX_DISTANCE then
					table.insert(state.npcCache, {model=npc, root=npcRoot, humanoid=hum, distance=dist})
				end
			end
		end
	end

	table.sort(state.npcCache, function(a,b) return a.distance < b.distance end)
end

local function findClosestNPC()
	local now = tick()
	if now - state.lastNPCScan > CONFIG.NPC_SCAN_INTERVAL then
		updateNPCCache()
		state.lastNPCScan = now
	end
	return state.npcCache[1] and state.npcCache[1].model
end

-- ===== ESP SYSTEM =====
local function createESP(npc)
	if state.espObjects[npc] then return end
	
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not npcRoot then return end
	
	local highlight = Instance.new("Highlight")
	highlight.Name = "FFREHighlight"
	highlight.Adornee = npc
	highlight.FillColor = Color3_fromRGB(255, 0, 0)
	highlight.OutlineColor = Color3_fromRGB(255, 255, 255)
	highlight.FillTransparency = 0.5
	highlight.OutlineTransparency = 0
	highlight.Parent = npc
	
	state.espObjects[npc] = highlight
end

local function removeESP(npc)
	if state.espObjects[npc] then
		state.espObjects[npc]:Destroy()
		state.espObjects[npc] = nil
	end
end

local function clearAllESP()
	for npc, esp in pairs(state.espObjects) do
		if esp then esp:Destroy() end
	end
	table.clear(state.espObjects)
end

-- ===== TRACERS SYSTEM =====
local function createTracer(npc)
	if state.tracerLines[npc] then return end
	
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not npcRoot then return end
	
	local line = Drawing.new("Line")
	line.Visible = true
	line.Color = Color3.new(0, 1, 0)
	line.Thickness = 2
	line.Transparency = 0.7
	
	state.tracerLines[npc] = line
end

local function updateTracers()
	if not state.tracersEnabled then return end
	
	local camera = workspace.CurrentCamera
	
	for npc, line in pairs(state.tracerLines) do
		if npc and npc.Parent then
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			if npcRoot then
				local npcPos, onScreen = camera:WorldToViewportPoint(npcRoot.Position)
				local screenSize = camera.ViewportSize
				
				if onScreen then
					line.From = Vector2.new(screenSize.X / 2, screenSize.Y)
					line.To = Vector2.new(npcPos.X, npcPos.Y)
					line.Visible = true
				else
					line.Visible = false
				end
			else
				line.Visible = false
			end
		else
			line.Visible = false
		end
	end
end

local function removeTracer(npc)
	if state.tracerLines[npc] then
		state.tracerLines[npc]:Remove()
		state.tracerLines[npc] = nil
	end
end

local function clearAllTracers()
	for npc, line in pairs(state.tracerLines) do
		if line then line:Remove() end
	end
	table.clear(state.tracerLines)
end

-- ===== HEALTH BAR SYSTEM =====
local function createHealthBar(npc)
	if state.healthBarObjects[npc] then return end
	
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	local npcHum = npc:FindFirstChild("Humanoid")
	if not npcRoot or not npcHum then return end
	
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "FFREHealthBar"
	billboardGui.Adornee = npcRoot
	billboardGui.Size = UDim2_new(4, 0, 0.5, 0)
	billboardGui.StudsOffset = Vector3_new(0, 3, 0)
	billboardGui.AlwaysOnTop = true
	billboardGui.Parent = npc
	
	local frame = Instance.new("Frame")
	frame.Size = UDim2_new(1, 0, 1, 0)
	frame.BackgroundColor3 = Color3_fromRGB(40, 40, 40)
	frame.BorderSizePixel = 0
	frame.Parent = billboardGui
	
	local healthBar = Instance.new("Frame")
	healthBar.Name = "HealthBar"
	healthBar.Size = UDim2_new(npcHum.Health / npcHum.MaxHealth, 0, 1, 0)
	healthBar.BackgroundColor3 = Color3_fromRGB(0, 255, 0)
	healthBar.BorderSizePixel = 0
	healthBar.Parent = frame
	
	local healthText = Instance.new("TextLabel")
	healthText.Name = "HealthText"
	healthText.Size = UDim2_new(1, 0, 1, 0)
	healthText.BackgroundTransparency = 1
	healthText.Text = math.floor(npcHum.Health) .. "/" .. math.floor(npcHum.MaxHealth)
	healthText.TextColor3 = Color3_white
	healthText.TextScaled = true
	healthText.Font = Enum.Font.GothamBold
	healthText.Parent = frame
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = frame
	
	local corner2 = Instance.new("UICorner")
	corner2.CornerRadius = UDim.new(0, 4)
	corner2.Parent = healthBar
	
	state.healthBarObjects[npc] = billboardGui
end

local function updateHealthBar(npc)
	local healthBarGui = state.healthBarObjects[npc]
	if not healthBarGui then return end
	
	local npcHum = npc:FindFirstChild("Humanoid")
	if not npcHum then return end
	
	local healthBar = healthBarGui:FindFirstChild("Frame"):FindFirstChild("HealthBar")
	local healthText = healthBarGui:FindFirstChild("Frame"):FindFirstChild("HealthText")
	
	if healthBar and healthText then
		local healthPercent = npcHum.Health / npcHum.MaxHealth
		healthBar.Size = UDim2_new(healthPercent, 0, 1, 0)
		healthText.Text = math.floor(npcHum.Health) .. "/" .. math.floor(npcHum.MaxHealth)
		
		if healthPercent > 0.5 then
			healthBar.BackgroundColor3 = Color3_fromRGB(0, 255, 0)
		elseif healthPercent > 0.25 then
			healthBar.BackgroundColor3 = Color3_fromRGB(255, 255, 0)
		else
			healthBar.BackgroundColor3 = Color3_fromRGB(255, 0, 0)
		end
	end
end

local function removeHealthBar(npc)
	if state.healthBarObjects[npc] then
		state.healthBarObjects[npc]:Destroy()
		state.healthBarObjects[npc] = nil
	end
end

local function clearAllHealthBars()
	for npc, gui in pairs(state.healthBarObjects) do
		if gui then gui:Destroy() end
	end
	table.clear(state.healthBarObjects)
end

-- ===== VISUAL FEATURES UPDATE =====
local function updateVisuals()
	for _, npc in ipairs(AliveFolder:GetChildren()) do
		if npc:IsA("Model") and npc ~= player.Character then
			local hum = npc:FindFirstChild("Humanoid")
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			
			if hum and npcRoot and hum.Health > 0 then
				if state.espEnabled then
					createESP(npc)
				else
					removeESP(npc)
				end
				
				if state.tracersEnabled then
					createTracer(npc)
				else
					removeTracer(npc)
				end
				
				if state.healthBarsEnabled then
					createHealthBar(npc)
					updateHealthBar(npc)
				else
					removeHealthBar(npc)
				end
			else
				removeESP(npc)
				removeTracer(npc)
				removeHealthBar(npc)
			end
		end
	end
	
	updateTracers()
end

-- ===== ULTRA SMOOTH TELEPORT (ANTI-KICK) =====
local function ultraSmoothTeleport(targetPosition)
	if state.isTeleporting then
		return false
	end
	
	local root, _, _ = getCharComponents()
	if not root then return false end
	
	state.isTeleporting = true
	
	local startPos = root.Position
	local distance = (targetPosition - startPos).Magnitude
	
	-- If very close, just teleport
	if distance < 10 then
		root.CFrame = CFrame_new(targetPosition)
		state.isTeleporting = false
		return true
	end
	
	-- Calculate travel time based on distance
	local travelTime = distance / CONFIG.TELEPORT_SPEED
	
	-- If distance is huge, break into chunks
	if distance > CONFIG.MAX_TELEPORT_DISTANCE then
		local direction = (targetPosition - startPos).Unit
		local numChunks = math.ceil(distance / CONFIG.MAX_TELEPORT_DISTANCE)
		
		for i = 1, numChunks do
			if not state.isTeleporting then break end
			
			local chunkTarget
			if i == numChunks then
				chunkTarget = targetPosition
			else
				chunkTarget = startPos + (direction * CONFIG.MAX_TELEPORT_DISTANCE * i)
			end
			
			local chunkDistance = (chunkTarget - root.Position).Magnitude
			local chunkTime = chunkDistance / CONFIG.TELEPORT_SPEED
			
			local tweenInfo = TweenInfo.new(
				chunkTime,
				Enum.EasingStyle.Linear,
				Enum.EasingDirection.Out
			)
			
			local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame_new(chunkTarget)})
			tween:Play()
			tween.Completed:Wait()
			
			task.wait(0.1) -- Small delay between chunks
		end
	else
		-- Single smooth tween
		local tweenInfo = TweenInfo.new(
			travelTime,
			Enum.EasingStyle.Linear,
			Enum.EasingDirection.Out
		)
		
		local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame_new(targetPosition)})
		tween:Play()
		tween.Completed:Wait()
	end
	
	state.isTeleporting = false
	return true
end

local function safeTeleportToNPC(npcName)
	local root, _, _ = getCharComponents()
	if not root then return false, "Character not found" end
	
	for _, npc in ipairs(AliveFolder:GetChildren()) do
		if npc.Name == npcName and npc:IsA("Model") then
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			if npcRoot then
				local targetPos = npcRoot.Position + Vector3_new(0, 2, 5)
				
				task.spawn(function()
					ultraSmoothTeleport(targetPos)
				end)
				
				return true, "Teleporting..."
			end
		end
	end
	
	return false, "NPC not found"
end

local function getNPCList()
	local npcList = {}
	for _, npc in ipairs(AliveFolder:GetChildren()) do
		if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
			if not table.find(npcList, npc.Name) then
				table.insert(npcList, npc.Name)
			end
		end
	end
	table.sort(npcList)
	return npcList
end

-- ===== LOCK ON TARGET =====
local function lockOnLoop()
	if not state.lockOnEnabled then return end
	
	local camera = workspace.CurrentCamera
	local target = state.lockedTarget
	
	-- If autofarm is active, use autofarm target
	if state.autofarmEnabled and state.lockedNPC then
		target = state.lockedNPC
	end
	
	-- Otherwise find closest NPC
	if not target or not target.Parent then
		target = findClosestNPC()
		state.lockedTarget = target
	end
	
	if target then
		local npcRoot = target:FindFirstChild("HumanoidRootPart")
		if npcRoot then
			camera.CFrame = CFrame_new(camera.CFrame.Position, npcRoot.Position)
		end
	end
end

-- ===== M1 MACRO =====
local function simulateMouseClick()
	local virtualInput = game:GetService("VirtualInputManager")
	virtualInput:SendMouseButtonEvent(0, 0, 0, true, game, 0)
	task.wait(0.01)
	virtualInput:SendMouseButtonEvent(0, 0, 0, false, game, 0)
end

local function m1MacroLoop()
	if not state.m1MacroEnabled then return end
	local now = tick()
	if now - state.lastM1Click >= state.m1ClickDelay then
		pcall(simulateMouseClick)
		state.lastM1Click = now
	end
end

-- ===== AUTOFARM =====
local function isNPCValid(npc)
	if not npc or not npc.Parent then return false end
	local hum = npc:FindFirstChild("Humanoid")
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not hum or not npcRoot or hum.Health <= 0 then return false end
	
	local root, _, _ = getCharComponents()
	if not root then return false end
	
	local dist = (root.Position - npcRoot.Position).Magnitude
	return dist <= CONFIG.MAX_DISTANCE
end

local function autofarmLoop()
	if not state.autofarmEnabled then return end
	local root, _, _ = getCharComponents()
	if not root then return end

	if not isNPCValid(state.lockedNPC) then
		state.lockedNPC = findClosestNPC()
	end

	local npc = state.lockedNPC
	if not npc then return end

	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not npcRoot then
		state.lockedNPC = nil
		return
	end

	local npcCFrame = npcRoot.CFrame
	local backVector = -npcCFrame.LookVector * CONFIG.BACK_DISTANCE
	local upVector = Vector3_new(0, CONFIG.HEIGHT_OFFSET, 0)
	local targetCFrame = CFrame_new(npcRoot.Position + backVector + upVector)

	root.AssemblyLinearVelocity = Vector3_zero
	root.AssemblyAngularVelocity = Vector3_zero
	root.CFrame = targetCFrame
end

-- ===== SPEED BOOST =====
local function speedLoop()
	if not state.speedEnabled then return end
	local root, hum, _ = getCharComponents()
	if root and hum then
		local moveDir = hum.MoveDirection
		if moveDir.Magnitude > 0 then
			local currentY = root.AssemblyLinearVelocity.Y
			root.AssemblyLinearVelocity = (moveDir.Unit * state.speedValue) + Vector3_new(0, currentY, 0)
		end
	end
end

-- ===== CLEANUP OLD GUI =====
pcall(function()
	CoreGui:FindFirstChild(CONFIG.GUI_NAME):Destroy()
end)

-- ===== GUI CREATION (NS HUB EXACT STYLE) =====
local screenGui = Instance.new("ScreenGui")
screenGui.Name = CONFIG.GUI_NAME
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = CoreGui

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2_new(0, 320, 0, 450)
mainFrame.Position = UDim2_new(0, 20, 0.5, -225)
mainFrame.BackgroundColor3 = Color3_fromRGB(13, 13, 18)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

-- Border Gradient
local borderGradient = Instance.new("UIStroke")
borderGradient.Color = Color3_fromRGB(100, 100, 120)
borderGradient.Thickness = 1
borderGradient.Transparency = 0.5
borderGradient.Parent = mainFrame

-- Header
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2_new(1, 0, 0, 35)
header.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
header.BorderSizePixel = 0
header.Parent = mainFrame

local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 8)
headerCorner.Parent = header

local headerFill = Instance.new("Frame")
headerFill.Size = UDim2_new(1, 0, 0, 8)
headerFill.Position = UDim2_new(0, 0, 1, -8)
headerFill.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
headerFill.BorderSizePixel = 0
headerFill.Parent = header

-- Title with Icon
local titleContainer = Instance.new("Frame")
titleContainer.Size = UDim2_new(1, -80, 1, 0)
titleContainer.Position = UDim2_new(0, 10, 0, 0)
titleContainer.BackgroundTransparency = 1
titleContainer.Parent = header

local titleIcon = Instance.new("TextLabel")
titleIcon.Size = UDim2_new(0, 20, 1, 0)
titleIcon.BackgroundTransparency = 1
titleIcon.Text = "‚ú¶"
titleIcon.Font = Enum.Font.GothamBold
titleIcon.TextSize = 16
titleIcon.TextColor3 = Color3_fromRGB(100, 180, 255)
titleIcon.TextXAlignment = Enum.TextXAlignment.Left
titleIcon.Parent = titleContainer

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2_new(1, -25, 1, 0)
titleLabel.Position = UDim2_new(0, 25, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "NS HUB"
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 13
titleLabel.TextColor3 = Color3_white
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleContainer

local versionLabel = Instance.new("TextLabel")
versionLabel.Size = UDim2_new(0, 80, 1, 0)
versionLabel.Position = UDim2_new(1, -90, 0, 0)
versionLabel.BackgroundTransparency = 1
versionLabel.Text = "1.0" 
versionLabel.Font = Enum.Font.Gotham
versionLabel.TextSize = 11
versionLabel.TextColor3 = Color3_fromRGB(120, 120, 140)
versionLabel.TextXAlignment = Enum.TextXAlignment.Right
versionLabel.Parent = header

-- Close/Minimize Buttons
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2_new(0, 25, 0, 25)
closeBtn.Position = UDim2_new(1, -30, 0, 5)
closeBtn.BackgroundColor3 = Color3_fromRGB(25, 25, 35)
closeBtn.Text = "√ó"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 18
closeBtn.TextColor3 = Color3_fromRGB(200, 200, 210)
closeBtn.BorderSizePixel = 0
closeBtn.Parent = header

local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(0, 4)
closeBtnCorner.Parent = closeBtn

closeBtn.MouseButton1Click:Connect(function()
	screenGui:Destroy()
end)

-- Sidebar
local sidebar = Instance.new("Frame")
sidebar.Name = "Sidebar"
sidebar.Size = UDim2_new(0, 45, 1, -40)
sidebar.Position = UDim2_new(0, 5, 0, 38)
sidebar.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
sidebar.BorderSizePixel = 0
sidebar.Parent = mainFrame

local sidebarCorner = Instance.new("UICorner")
sidebarCorner.CornerRadius = UDim.new(0, 6)
sidebarCorner.Parent = sidebar

local sidebarLayout = Instance.new("UIListLayout")
sidebarLayout.Padding = UDim.new(0, 5)
sidebarLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
sidebarLayout.Parent = sidebar

local sidebarPadding = Instance.new("UIPadding")
sidebarPadding.PaddingTop = UDim.new(0, 8)
sidebarPadding.Parent = sidebar

-- Helper: Create Sidebar Button
local function createSidebarBtn(icon, name)
	local btn = Instance.new("TextButton")
	btn.Name = name
	btn.Size = UDim2_new(0, 35, 0, 35)
	btn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	btn.Text = icon
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 16
	btn.TextColor3 = Color3_fromRGB(120, 120, 140)
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = false
	btn.Parent = sidebar
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = btn
	
	return btn
end

-- MODIFICADO: Removido o bot√£o de Config da sidebar
local combatBtn = createSidebarBtn("‚öî", "CombatBtn")
local visualBtn = createSidebarBtn("üëÅ", "VisualBtn")
local teleportBtn = createSidebarBtn("üìç", "TeleportBtn")

-- Content Area
local contentArea = Instance.new("Frame")
contentArea.Name = "ContentArea"
contentArea.Size = UDim2_new(1, -60, 1, -40)
contentArea.Position = UDim2_new(0, 55, 0, 38)
contentArea.BackgroundTransparency = 1
contentArea.Parent = mainFrame

-- Helper: Create Page
local function createPage(name)
	local page = Instance.new("ScrollingFrame")
	page.Name = name
	page.Size = UDim2_new(1, -5, 1, 0)
	page.BackgroundTransparency = 1
	page.BorderSizePixel = 0
	page.ScrollBarThickness = 3
	page.ScrollBarImageColor3 = Color3_fromRGB(80, 80, 100)
	page.CanvasSize = UDim2_new(0, 0, 0, 0)
	page.AutomaticCanvasSize = Enum.AutomaticSize.Y
	page.Visible = false
	page.Parent = contentArea
	
	local pageLayout = Instance.new("UIListLayout")
	pageLayout.Padding = UDim.new(0, 8)
	pageLayout.SortOrder = Enum.SortOrder.LayoutOrder
	pageLayout.Parent = page
	
	local pagePadding = Instance.new("UIPadding")
	pagePadding.PaddingRight = UDim.new(0, 5)
	pagePadding.Parent = page
	
	return page
end

-- MODIFICADO: Removida a p√°gina de Config
local combatPage = createPage("CombatPage")
local visualPage = createPage("VisualPage")
local teleportPage = createPage("TeleportPage")

-- Page Switching
local function switchPage(page, btn)
	combatPage.Visible = false
	visualPage.Visible = false
	teleportPage.Visible = false
	
	combatBtn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	combatBtn.TextColor3 = Color3_fromRGB(120, 120, 140)
	visualBtn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	visualBtn.TextColor3 = Color3_fromRGB(120, 120, 140)
	teleportBtn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	teleportBtn.TextColor3 = Color3_fromRGB(120, 120, 140)
	
	page.Visible = true
	btn.BackgroundColor3 = Color3_fromRGB(100, 180, 255)
	btn.TextColor3 = Color3_white
end

combatBtn.MouseButton1Click:Connect(function()
	switchPage(combatPage, combatBtn)
end)

visualBtn.MouseButton1Click:Connect(function()
	switchPage(visualPage, visualBtn)
end)

teleportBtn.MouseButton1Click:Connect(function()
	switchPage(teleportPage, teleportBtn)
end)

-- Initialize
switchPage(combatPage, combatBtn)

-- Helper: Create Section Header
local function createSectionHeader(parent, text)
	local header = Instance.new("Frame")
	header.Size = UDim2_new(1, 0, 0, 30)
	header.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
	header.BorderSizePixel = 0
	header.Parent = parent
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 6)
	headerCorner.Parent = header
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2_new(1, -15, 1, 0)
	label.Position = UDim2_new(0, 10, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.Font = Enum.Font.GothamBold
	label.TextSize = 12
	label.TextColor3 = Color3_fromRGB(180, 180, 200)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = header
	
	local icon = Instance.new("TextLabel")
	icon.Size = UDim2_new(0, 15, 1, 0)
	icon.BackgroundTransparency = 1
	icon.Text = "‚óá"
	icon.Font = Enum.Font.GothamBold
	icon.TextSize = 10
	icon.TextColor3 = Color3_fromRGB(100, 180, 255)
	icon.TextXAlignment = Enum.TextXAlignment.Left
	icon.Parent = label
	
	return header
end

-- Helper: Create Toggle
local function createToggle(parent, labelText, descText, defaultState)
	local container = Instance.new("Frame")
	container.Size = UDim2_new(1, 0, 0, descText and 55 or 40)
	container.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
	container.BorderSizePixel = 0
	container.Parent = parent
	
	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 6)
	containerCorner.Parent = container
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2_new(0.7, -10, 0, 20)
	label.Position = UDim2_new(0, 10, 0, descText and 8 or 10)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = Enum.Font.Gotham
	label.TextSize = 12
	label.TextColor3 = Color3_white
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = container
	
	if descText then
		local desc = Instance.new("TextLabel")
		desc.Size = UDim2_new(1, -20, 0, 18)
		desc.Position = UDim2_new(0, 10, 0, 28)
		desc.BackgroundTransparency = 1
		desc.Text = descText
		desc.Font = Enum.Font.Gotham
		desc.TextSize = 9
		desc.TextColor3 = Color3_fromRGB(120, 120, 140)
		desc.TextXAlignment = Enum.TextXAlignment.Left
		desc.TextWrapped = true
		desc.Parent = container
	end
	
	-- Toggle Button (NS HUB Style)
	local toggleBg = Instance.new("Frame")
	toggleBg.Size = UDim2_new(0, 38, 0, 20)
	toggleBg.Position = UDim2_new(1, -45, 0, descText and 10 or 10)
	toggleBg.BackgroundColor3 = defaultState and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	toggleBg.BorderSizePixel = 0
	toggleBg.Parent = container
	
	local toggleBgCorner = Instance.new("UICorner")
	toggleBgCorner.CornerRadius = UDim.new(1, 0)
	toggleBgCorner.Parent = toggleBg
	
	local toggleCircle = Instance.new("Frame")
	toggleCircle.Size = UDim2_new(0, 16, 0, 16)
	toggleCircle.Position = defaultState and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	toggleCircle.BackgroundColor3 = Color3_white
	toggleCircle.BorderSizePixel = 0
	toggleCircle.Parent = toggleBg
	
	local toggleCircleCorner = Instance.new("UICorner")
	toggleCircleCorner.CornerRadius = UDim.new(1, 0)
	toggleCircleCorner.Parent = toggleCircle
	
	local toggleBtn = Instance.new("TextButton")
	toggleBtn.Size = UDim2_new(1, 0, 1, 0)
	toggleBtn.BackgroundTransparency = 1
	toggleBtn.Text = ""
	toggleBtn.Parent = toggleBg
	
	return container, toggleBtn, toggleBg, toggleCircle
end

-- Helper: Create Slider
local function createSlider(parent, labelText, minVal, maxVal, defaultVal)
	local container = Instance.new("Frame")
	container.Size = UDim2_new(1, 0, 0, 50)
	container.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
	container.BorderSizePixel = 0
	container.Parent = parent
	
	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 6)
	containerCorner.Parent = container
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2_new(0.6, 0, 0, 18)
	label.Position = UDim2_new(0, 10, 0, 8)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = Enum.Font.Gotham
	label.TextSize = 11
	label.TextColor3 = Color3_white
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = container
	
	local valueLabel = Instance.new("TextLabel")
	valueLabel.Size = UDim2_new(0, 50, 0, 18)
	valueLabel.Position = UDim2_new(1, -55, 0, 8)
	valueLabel.BackgroundTransparency = 1
	valueLabel.Text = tostring(defaultVal)
	valueLabel.Font = Enum.Font.GothamBold
	valueLabel.TextSize = 11
	valueLabel.TextColor3 = Color3_fromRGB(100, 180, 255)
	valueLabel.TextXAlignment = Enum.TextXAlignment.Right
	valueLabel.Parent = container
	
	-- Slider
	local sliderBg = Instance.new("Frame")
	sliderBg.Size = UDim2_new(1, -20, 0, 4)
	sliderBg.Position = UDim2_new(0, 10, 1, -15)
	sliderBg.BackgroundColor3 = Color3_fromRGB(30, 30, 42)
	sliderBg.BorderSizePixel = 0
	sliderBg.Parent = container
	
	local sliderBgCorner = Instance.new("UICorner")
	sliderBgCorner.CornerRadius = UDim.new(1, 0)
	sliderBgCorner.Parent = sliderBg
	
	local sliderFill = Instance.new("Frame")
	sliderFill.Size = UDim2_new((defaultVal - minVal) / (maxVal - minVal), 0, 1, 0)
	sliderFill.BackgroundColor3 = Color3_fromRGB(100, 180, 255)
	sliderFill.BorderSizePixel = 0
	sliderFill.Parent = sliderBg
	
	local sliderFillCorner = Instance.new("UICorner")
	sliderFillCorner.CornerRadius = UDim.new(1, 0)
	sliderFillCorner.Parent = sliderFill
	
	local sliderBtn = Instance.new("TextButton")
	sliderBtn.Size = UDim2_new(1, 0, 1, 10)
	sliderBtn.Position = UDim2_new(0, 0, 0, -5)
	sliderBtn.BackgroundTransparency = 1
	sliderBtn.Text = ""
	sliderBtn.Parent = sliderBg
	
	return container, sliderBtn, sliderFill, valueLabel, minVal, maxVal
end

-- Helper: Create Button
local function createButton(parent, text, color)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2_new(1, 0, 0, 35)
	btn.BackgroundColor3 = color or Color3_fromRGB(100, 180, 255)
	btn.Text = text
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 12
	btn.TextColor3 = Color3_white
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = false
	btn.Parent = parent
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = btn
	
	return btn
end

-- ===== COMBAT PAGE =====
createSectionHeader(combatPage, "Combat Settings")

local autofarmContainer, autofarmToggle, autofarmBg, autofarmCircle = createToggle(
	combatPage, 
	"Auto Farm", 
	"Automatically farm the closest NPC",
	state.autofarmEnabled
)

local lockOnContainer, lockOnToggle, lockOnBg, lockOnCircle = createToggle(
	combatPage,
	"Lock On Target",
	"Camera locks onto nearest enemy",
	state.lockOnEnabled
)

local m1Container, m1Toggle, m1Bg, m1Circle = createToggle(
	combatPage,
	"M1 Auto Click (F2)",
	"Automatically click M1 button",
	state.m1MacroEnabled
)

local m1SliderContainer, m1SliderBtn, m1SliderFill, m1ValueLabel, m1Min, m1Max = createSlider(
	combatPage,
	"M1 Click Delay",
	0.05,
	1,
	state.m1ClickDelay
)

createSectionHeader(combatPage, "Movement Settings")

local speedContainer, speedToggle, speedBg, speedCircle = createToggle(
	combatPage,
	"Speed Boost",
	"Increase movement speed",
	state.speedEnabled
)

local speedSliderContainer, speedSliderBtn, speedSliderFill, speedValueLabel, speedMin, speedMax = createSlider(
	combatPage,
	"Speed Value",
	50,
	300,
	state.speedValue
)

local jumpContainer, jumpToggle, jumpBg, jumpCircle = createToggle(
	combatPage,
	"Infinite Jump",
	"Jump infinitely without limit",
	state.infiniteJumpEnabled
)

-- ===== VISUAL PAGE =====
createSectionHeader(visualPage, "Visual Features")

local espContainer, espToggle, espBg, espCircle = createToggle(
	visualPage,
	"ESP Highlights",
	"See NPCs through walls",
	state.espEnabled
)

local tracersContainer, tracersToggle, tracersBg, tracersCircle = createToggle(
	visualPage,
	"Tracers",
	"Lines pointing to NPCs",
	state.tracersEnabled
)

local healthBarsContainer, healthBarsToggle, healthBarsBg, healthBarsCircle = createToggle(
	visualPage,
	"Health Bars",
	"Display NPC health bars",
	state.healthBarsEnabled
)

-- ===== TELEPORT PAGE =====
createSectionHeader(teleportPage, "Safe Teleport System")

local tpInfoContainer = Instance.new("Frame")
tpInfoContainer.Size = UDim2_new(1, 0, 0, 60)
tpInfoContainer.BackgroundColor3 = Color3_fromRGB(100, 180, 255)
tpInfoContainer.BackgroundTransparency = 0.9
tpInfoContainer.BorderSizePixel = 0
tpInfoContainer.Parent = teleportPage

local tpInfoCorner = Instance.new("UICorner")
tpInfoCorner.CornerRadius = UDim.new(0, 6)
tpInfoCorner.Parent = tpInfoContainer

local tpInfoLabel = Instance.new("TextLabel")
tpInfoLabel.Size = UDim2_new(1, -20, 1, 0)
tpInfoLabel.Position = UDim2_new(0, 10, 0, 0)
tpInfoLabel.BackgroundTransparency = 1
tpInfoLabel.Text = "üìç Ultra Smooth Teleport\nAnti-kick protection for long distances\nClick any NPC to teleport safely"
tpInfoLabel.Font = Enum.Font.Gotham
tpInfoLabel.TextSize = 10
tpInfoLabel.TextColor3 = Color3_white
tpInfoLabel.TextXAlignment = Enum.TextXAlignment.Left
tpInfoLabel.TextWrapped = true
tpInfoLabel.Parent = tpInfoContainer

local refreshNPCBtn = createButton(teleportPage, "üîÑ Refresh NPC List", Color3_fromRGB(80, 200, 120))

local npcListContainer = Instance.new("Frame")
npcListContainer.Name = "NPCListContainer"
npcListContainer.Size = UDim2_new(1, 0, 0, 0)
npcListContainer.AutomaticSize = Enum.AutomaticSize.Y
npcListContainer.BackgroundTransparency = 1
npcListContainer.Parent = teleportPage

local npcListLayout = Instance.new("UIListLayout")
npcListLayout.Padding = UDim.new(0, 5)
npcListLayout.SortOrder = Enum.SortOrder.LayoutOrder
npcListLayout.Parent = npcListContainer

local function populateNPCList()
	for _, child in ipairs(npcListContainer:GetChildren()) do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end
	
	local npcList = getNPCList()
	
	for _, npcName in ipairs(npcList) do
		local npcBtn = Instance.new("TextButton")
		npcBtn.Size = UDim2_new(1, 0, 0, 32)
		npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
		npcBtn.Text = "   üìå " .. npcName
		npcBtn.Font = Enum.Font.Gotham
		npcBtn.TextSize = 11
		npcBtn.TextColor3 = Color3_white
		npcBtn.TextXAlignment = Enum.TextXAlignment.Left
		npcBtn.BorderSizePixel = 0
		npcBtn.AutoButtonColor = false
		npcBtn.Parent = npcListContainer
		
		local npcBtnCorner = Instance.new("UICorner")
		npcBtnCorner.CornerRadius = UDim.new(0, 6)
		npcBtnCorner.Parent = npcBtn
		
		npcBtn.MouseEnter:Connect(function()
			npcBtn.BackgroundColor3 = Color3_fromRGB(25, 25, 35)
		end)
		
		npcBtn.MouseLeave:Connect(function()
			npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
		end)
		
		npcBtn.MouseButton1Click:Connect(function()
			local success, msg = safeTeleportToNPC(npcName)
			if success then
				npcBtn.BackgroundColor3 = Color3_fromRGB(80, 200, 120)
				task.wait(0.5)
				npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
			else
				npcBtn.BackgroundColor3 = Color3_fromRGB(200, 50, 50)
				task.wait(0.5)
				npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
			end
		end)
	end
end

refreshNPCBtn.MouseButton1Click:Connect(populateNPCList)

task.spawn(function()
	task.wait(1)
	populateNPCList()
end)

-- ===== TOGGLE FUNCTIONS =====
toggleUpdateFunctions = {}

-- Autofarm
toggleUpdateFunctions.autofarm = function(enabled)
	state.autofarmEnabled = enabled
	
	TweenService:Create(autofarmBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(autofarmCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("autofarm")
		state.connections.autofarm = RunService.Heartbeat:Connect(autofarmLoop)
	else
		disconnectConnection("autofarm")
		state.lockedNPC = nil
	end
end

autofarmToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.autofarm(not state.autofarmEnabled)
end)

-- Lock On Target
toggleUpdateFunctions.lockOn = function(enabled)
	state.lockOnEnabled = enabled
	
	TweenService:Create(lockOnBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(lockOnCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("lockOn")
		state.connections.lockOn = RunService.RenderStepped:Connect(lockOnLoop)
	else
		disconnectConnection("lockOn")
		state.lockedTarget = nil
	end
end

lockOnToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.lockOn(not state.lockOnEnabled)
end)

-- M1 Macro
toggleUpdateFunctions.m1Macro = function(enabled)
	state.m1MacroEnabled = enabled
	
	TweenService:Create(m1Bg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(m1Circle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("m1macro")
		state.connections.m1macro = RunService.Heartbeat:Connect(m1MacroLoop)
	else
		disconnectConnection("m1macro")
	end
end

m1Toggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.m1Macro(not state.m1MacroEnabled)
end)

-- M1 Slider
local m1Dragging = false
m1SliderBtn.MouseButton1Down:Connect(function()
	m1Dragging = true
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		m1Dragging = false
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if m1Dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local sliderBg = m1SliderBtn.Parent
		local mousePos = UserInputService:GetMouseLocation().X
		local sliderPos = sliderBg.AbsolutePosition.X
		local sliderSize = sliderBg.AbsoluteSize.X
		local percent = math.clamp((mousePos - sliderPos) / sliderSize, 0, 1)
		local value = m1Min + (percent * (m1Max - m1Min))
		value = math.floor(value * 100) / 100
		
		state.m1ClickDelay = value
		m1ValueLabel.Text = tostring(value)
		m1SliderFill.Size = UDim2_new(percent, 0, 1, 0)
	end
end)

-- Speed
toggleUpdateFunctions.speed = function(enabled)
	state.speedEnabled = enabled
	
	TweenService:Create(speedBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(speedCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("speed")
		state.connections.speed = RunService.Heartbeat:Connect(speedLoop)
	else
		disconnectConnection("speed")
	end
end

speedToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.speed(not state.speedEnabled)
end)

-- Speed Slider
local speedDragging = false
speedSliderBtn.MouseButton1Down:Connect(function()
	speedDragging = true
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		speedDragging = false
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if speedDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local sliderBg = speedSliderBtn.Parent
		local mousePos = UserInputService:GetMouseLocation().X
		local sliderPos = sliderBg.AbsolutePosition.X
		local sliderSize = sliderBg.AbsoluteSize.X
		local percent = math.clamp((mousePos - sliderPos) / sliderSize, 0, 1)
		local value = speedMin + (percent * (speedMax - speedMin))
		value = math.floor(value)
		
		state.speedValue = value
		speedValueLabel.Text = tostring(value)
		speedSliderFill.Size = UDim2_new(percent, 0, 1, 0)
	end
end)

-- Infinite Jump
toggleUpdateFunctions.infiniteJump = function(enabled)
	state.infiniteJumpEnabled = enabled
	
	TweenService:Create(jumpBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(jumpCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
end

jumpToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.infiniteJump(not state.infiniteJumpEnabled)
end)

-- ESP
toggleUpdateFunctions.esp = function(enabled)
	state.espEnabled = enabled
	
	TweenService:Create(espBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(espCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if not enabled then
		clearAllESP()
	end
end

espToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.esp(not state.espEnabled)
end)

-- Tracers
toggleUpdateFunctions.tracers = function(enabled)
	state.tracersEnabled = enabled
	
	TweenService:Create(tracersBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(tracersCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if not enabled then
		clearAllTracers()
	end
end

tracersToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.tracers(not state.tracersEnabled)
end)

-- Health Bars
toggleUpdateFunctions.healthBars = function(enabled)
	state.healthBarsEnabled = enabled
	
	TweenService:Create(healthBarsBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(healthBarsCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if not enabled then
		clearAllHealthBars()
	end
end

healthBarsToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.healthBars(not state.healthBarsEnabled)
end)

-- ===== VISUAL UPDATE LOOP =====
state.connections.visualUpdate = RunService.RenderStepped:Connect(updateVisuals)

-- ===== INPUT HANDLING =====
UserInputService.JumpRequest:Connect(function()
	if state.infiniteJumpEnabled then
		local _, hum, _ = getCharComponents()
		if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
	end
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end

	if input.KeyCode == Enum.KeyCode.F1 then
		state.guiVisible = not state.guiVisible
		mainFrame.Visible = state.guiVisible
	end

	if input.KeyCode == Enum.KeyCode.F2 then
		toggleUpdateFunctions.m1Macro(not state.m1MacroEnabled)
	end
end)

-- ===== CHARACTER EVENTS =====
player.CharacterAdded:Connect(function(char)
	invalidateCharCache()
	task.wait(0.3)
	
	if state.speedEnabled then
		disconnectConnection("speed")
		state.connections.speed = RunService.Heartbeat:Connect(speedLoop)
	end
	if state.m1MacroEnabled then
		disconnectConnection("m1macro")
		state.connections.m1macro = RunService.Heartbeat:Connect(m1MacroLoop)
	end
end)

-- ===== CLEANUP =====
screenGui.Destroying:Connect(function()
	cleanAllConnections()
	clearAllESP()
	clearAllTracers()
	clearAllHealthBars()
end)

-- ===== STARTUP =====
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  CyberHub - FFRE EDITION V4")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  ‚öîÔ∏è Combat: Auto Farm | Lock On | M1 Macro")
print("  ‚ö° Movement: Speed | Infinite Jump")
print("  üëÅÔ∏è Visual: ESP | Tracers | Health Bars")
print("  üìç Teleport: Ultra Smooth (Anti-Kick)")
print("  üìÅ NPC Folder: Workspace.LiveNPCS")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  F1 - Toggle GUI | F2 - Toggle M1 Macro")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
