-- ===== CYBER HUB - FFRE EDITION V4.3 =====
-- Ultra Smooth Teleport (Anti-Kick) + Lock On Target
-- ESP + Tracers + Health Bars (Workspace.Alive)
-- Dual Autofarm Mode: Behind / Above NPC

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
if not player then return end

-- ===== CONFIG =====
local CONFIG = {
	BACK_DISTANCE = 3.5,
	HEIGHT_OFFSET = 2.5,
	ABOVE_HEIGHT = 8,
	MAX_DISTANCE = 60,
	NPC_SCAN_INTERVAL = 0.3,
	M1_CLICK_DELAY = 0.15,
	CHAR_CACHE_UPDATE = 0.5,
	GUI_NAME = "CyberHub",
	TELEPORT_SPEED = 150,
	MAX_TELEPORT_DISTANCE = 500,
	VISUAL_NPC_FOLDER = workspace:WaitForChild("Alive"),
	TELEPORT_NPC_FOLDER = workspace:WaitForChild("LiveNPCS")
}

-- ===== CACHE =====
local Vector3_new = Vector3.new
local Vector3_zero = Vector3.zero
local CFrame_new = CFrame.new
local UDim2_new = UDim2.new
local Color3_fromRGB = Color3.fromRGB
local Color3_white = Color3.new(1,1,1)
local Color3_black = Color3.new(0,0,0)

-- ===== STATE =====
local state = {
	autofarmEnabled = false,
	autofarmMode = "Behind", -- "Behind" or "Above"
	infiniteJumpEnabled = false,
	speedEnabled = false,
	m1MacroEnabled = false,
	espEnabled = false,
	tracersEnabled = false,
	healthBarsEnabled = false,
	lockOnEnabled = false,
	speedValue = 160,
	m1ClickDelay = CONFIG.M1_CLICK_DELAY,
	lockedNPC = nil,
	lockedTarget = nil,
	lastNPCScan = 0,
	npcCache = {},
	lastM1Click = 0,
	connections = {},
	guiVisible = true,
	guiToggleKey = Enum.KeyCode.F1,
	charCache = {
		root = nil,
		humanoid = nil,
		character = nil,
		lastUpdate = 0
	},
	lastSpeedApply = 0,
	currentPage = "combat",
	espObjects = {},
	tracerLines = {},
	healthBarObjects = {},
	isTeleporting = false,
	teleportNPCList = {}
}

-- Additional global states
local noClipEnabled = false
local playerESPEnabled = false
local fovEnabled = false
local playerESPObjects = {}
local fovCircle = nil

-- ===== TOGGLE FUNCTIONS TABLE =====
local toggleUpdateFunctions = {}

-- ===== UTILS =====
local function disconnectConnection(name)
	if state.connections[name] then
		state.connections[name]:Disconnect()
		state.connections[name] = nil
	end
end

local function cleanAllConnections()
	for name, conn in pairs(state.connections) do
		if conn and conn.Connected then
			conn:Disconnect()
		end
	end
	table.clear(state.connections)
end

local function getCharComponents()
	local now = tick()
	if now - state.charCache.lastUpdate > CONFIG.CHAR_CACHE_UPDATE then
		local char = player.Character
		state.charCache.character = char
		state.charCache.root = char and char:FindFirstChild("HumanoidRootPart")
		state.charCache.humanoid = char and char:FindFirstChildOfClass("Humanoid")
		state.charCache.lastUpdate = now
	end
	return state.charCache.root, state.charCache.humanoid, state.charCache.character
end

local function invalidateCharCache()
	state.charCache.lastUpdate = 0
end

-- ===== NPC CACHE =====
local function updateNPCCache()
	table.clear(state.npcCache)
	local root, _, _ = getCharComponents()
	if not root then return end

	for _, npc in ipairs(CONFIG.VISUAL_NPC_FOLDER:GetChildren()) do
		if npc:IsA("Model") and npc ~= player.Character then
			local hum = npc:FindFirstChild("Humanoid")
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			if hum and npcRoot and hum.Health > 0 then
				local dist = (root.Position - npcRoot.Position).Magnitude
				if dist <= CONFIG.MAX_DISTANCE then
					table.insert(state.npcCache, {model=npc, root=npcRoot, humanoid=hum, distance=dist})
				end
			end
		end
	end

	table.sort(state.npcCache, function(a,b) return a.distance < b.distance end)
end

local function findClosestNPC()
	local now = tick()
	if now - state.lastNPCScan > CONFIG.NPC_SCAN_INTERVAL then
		updateNPCCache()
		state.lastNPCScan = now
	end
	return state.npcCache[1] and state.npcCache[1].model
end

-- ===== ESP SYSTEM =====
local function createESP(npc)
	if state.espObjects[npc] then return end
	
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not npcRoot then return end
	
	local highlight = Instance.new("Highlight")
	highlight.Name = "CyberHighlight"
	highlight.Adornee = npc
	highlight.FillColor = Color3_fromRGB(255, 0, 0)
	highlight.OutlineColor = Color3_fromRGB(255, 255, 255)
	highlight.FillTransparency = 0.5
	highlight.OutlineTransparency = 0
	highlight.Parent = npc
	
	state.espObjects[npc] = highlight
end

local function removeESP(npc)
	if state.espObjects[npc] then
		state.espObjects[npc]:Destroy()
		state.espObjects[npc] = nil
	end
end

local function clearAllESP()
	for npc, esp in pairs(state.espObjects) do
		if esp then esp:Destroy() end
	end
	table.clear(state.espObjects)
end

-- ===== TRACERS SYSTEM =====
local function createTracer(npc)
	if state.tracerLines[npc] then return end
	
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not npcRoot then return end
	
	local line = Drawing.new("Line")
	line.Visible = true
	line.Color = Color3.new(0, 1, 0)
	line.Thickness = 2
	line.Transparency = 0.7
	
	state.tracerLines[npc] = line
end

local function updateTracers()
	if not state.tracersEnabled then return end
	
	local camera = workspace.CurrentCamera
	
	for npc, line in pairs(state.tracerLines) do
		if npc and npc.Parent then
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			if npcRoot then
				local npcPos, onScreen = camera:WorldToViewportPoint(npcRoot.Position)
				local screenSize = camera.ViewportSize
				
				if onScreen then
					line.From = Vector2.new(screenSize.X / 2, screenSize.Y)
					line.To = Vector2.new(npcPos.X, npcPos.Y)
					line.Visible = true
				else
					line.Visible = false
				end
			else
				line.Visible = false
			end
		else
			line.Visible = false
		end
	end
end

local function removeTracer(npc)
	if state.tracerLines[npc] then
		state.tracerLines[npc]:Remove()
		state.tracerLines[npc] = nil
	end
end

local function clearAllTracers()
	for npc, line in pairs(state.tracerLines) do
		if line then line:Remove() end
	end
	table.clear(state.tracerLines)
end

-- ===== HEALTH BAR SYSTEM =====
local function createHealthBar(npc)
	if state.healthBarObjects[npc] then return end
	
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	local npcHum = npc:FindFirstChild("Humanoid")
	if not npcRoot or not npcHum then return end
	
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "CyberHealthBar"
	billboardGui.Adornee = npcRoot
	billboardGui.Size = UDim2_new(4, 0, 0.5, 0)
	billboardGui.StudsOffset = Vector3_new(0, 3, 0)
	billboardGui.AlwaysOnTop = true
	billboardGui.Parent = npc
	
	local frame = Instance.new("Frame")
	frame.Size = UDim2_new(1, 0, 1, 0)
	frame.BackgroundColor3 = Color3_fromRGB(40, 40, 40)
	frame.BorderSizePixel = 0
	frame.Parent = billboardGui
	
	local healthBar = Instance.new("Frame")
	healthBar.Name = "HealthBar"
	healthBar.Size = UDim2_new(npcHum.Health / npcHum.MaxHealth, 0, 1, 0)
	healthBar.BackgroundColor3 = Color3_fromRGB(0, 255, 0)
	healthBar.BorderSizePixel = 0
	healthBar.Parent = frame
	
	local healthText = Instance.new("TextLabel")
	healthText.Name = "HealthText"
	healthText.Size = UDim2_new(1, 0, 1, 0)
	healthText.BackgroundTransparency = 1
	healthText.Text = math.floor(npcHum.Health) .. "/" .. math.floor(npcHum.MaxHealth)
	healthText.TextColor3 = Color3_white
	healthText.TextScaled = true
	healthText.Font = Enum.Font.GothamBold
	healthText.Parent = frame
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = frame
	
	local corner2 = Instance.new("UICorner")
	corner2.CornerRadius = UDim.new(0, 4)
	corner2.Parent = healthBar
	
	state.healthBarObjects[npc] = billboardGui
end

local function updateHealthBar(npc)
	local healthBarGui = state.healthBarObjects[npc]
	if not healthBarGui then return end
	
	local npcHum = npc:FindFirstChild("Humanoid")
	if not npcHum then return end
	
	local healthBar = healthBarGui:FindFirstChild("Frame"):FindFirstChild("HealthBar")
	local healthText = healthBarGui:FindFirstChild("Frame"):FindFirstChild("HealthText")
	
	if healthBar and healthText then
		local healthPercent = npcHum.Health / npcHum.MaxHealth
		healthBar.Size = UDim2_new(healthPercent, 0, 1, 0)
		healthText.Text = math.floor(npcHum.Health) .. "/" .. math.floor(npcHum.MaxHealth)
		
		if healthPercent > 0.5 then
			healthBar.BackgroundColor3 = Color3_fromRGB(0, 255, 0)
		elseif healthPercent > 0.25 then
			healthBar.BackgroundColor3 = Color3_fromRGB(255, 255, 0)
		else
			healthBar.BackgroundColor3 = Color3_fromRGB(255, 0, 0)
		end
	end
end

local function removeHealthBar(npc)
	if state.healthBarObjects[npc] then
		state.healthBarObjects[npc]:Destroy()
		state.healthBarObjects[npc] = nil
	end
end

local function clearAllHealthBars()
	for npc, gui in pairs(state.healthBarObjects) do
		if gui then gui:Destroy() end
	end
	table.clear(state.healthBarObjects)
end

-- ===== VISUAL FEATURES UPDATE =====
local function updateVisuals()
	for _, npc in ipairs(CONFIG.VISUAL_NPC_FOLDER:GetChildren()) do
		if npc:IsA("Model") and npc ~= player.Character then
			local hum = npc:FindFirstChild("Humanoid")
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			
			if hum and npcRoot and hum.Health > 0 then
				if state.espEnabled then
					createESP(npc)
				else
					removeESP(npc)
				end
				
				if state.tracersEnabled then
					createTracer(npc)
				else
					removeTracer(npc)
				end
				
				if state.healthBarsEnabled then
					createHealthBar(npc)
					updateHealthBar(npc)
				else
					removeHealthBar(npc)
				end
			else
				removeESP(npc)
				removeTracer(npc)
				removeHealthBar(npc)
			end
		end
	end
	
	updateTracers()
end

-- ===== PLAYER ESP =====
local function updatePlayerESP()
	if not playerESPEnabled then
		for player, esp in pairs(playerESPObjects) do
			if esp then esp:Destroy() end
		end
		table.clear(playerESPObjects)
		return
	end
	
	for _, otherPlayer in ipairs(Players:GetPlayers()) do
		if otherPlayer ~= player and otherPlayer.Character then
			local char = otherPlayer.Character
			
			if not playerESPObjects[otherPlayer] then
				local highlight = Instance.new("Highlight")
				highlight.Name = "PlayerHighlight"
				highlight.Adornee = char
				highlight.FillColor = Color3_fromRGB(0, 255, 255)
				highlight.OutlineColor = Color3_fromRGB(255, 255, 255)
				highlight.FillTransparency = 0.7
				highlight.OutlineTransparency = 0
				highlight.Parent = char
				
				playerESPObjects[otherPlayer] = highlight
			end
		end
	end
end

-- ===== FOV CIRCLE =====
local function createFOVCircle()
	if fovCircle then return end
	
	fovCircle = Drawing.new("Circle")
	fovCircle.Visible = true
	fovCircle.Thickness = 2
	fovCircle.Color = Color3.new(1, 1, 1)
	fovCircle.Transparency = 0.7
	fovCircle.NumSides = 60
	fovCircle.Radius = 150
	fovCircle.Filled = false
end

local function updateFOVCircle()
	if not fovEnabled or not fovCircle then return end
	
	local camera = workspace.CurrentCamera
	local screenSize = camera.ViewportSize
	
	fovCircle.Position = Vector2.new(screenSize.X / 2, screenSize.Y / 2)
	fovCircle.Visible = true
end

local function removeFOVCircle()
	if fovCircle then
		fovCircle:Remove()
		fovCircle = nil
	end
end

-- ===== ULTRA SMOOTH TELEPORT =====
local function ultraSmoothTeleport(targetPosition)
	if state.isTeleporting then
		return false
	end
	
	local root, _, _ = getCharComponents()
	if not root then return false end
	
	state.isTeleporting = true
	
	local startPos = root.Position
	local distance = (targetPosition - startPos).Magnitude
	
	if distance < 10 then
		root.CFrame = CFrame_new(targetPosition)
		state.isTeleporting = false
		return true
	end
	
	local travelTime = distance / CONFIG.TELEPORT_SPEED
	
	if distance > CONFIG.MAX_TELEPORT_DISTANCE then
		local direction = (targetPosition - startPos).Unit
		local numChunks = math.ceil(distance / CONFIG.MAX_TELEPORT_DISTANCE)
		
		for i = 1, numChunks do
			if not state.isTeleporting then break end
			
			local chunkTarget
			if i == numChunks then
				chunkTarget = targetPosition
			else
				chunkTarget = startPos + (direction * CONFIG.MAX_TELEPORT_DISTANCE * i)
			end
			
			local chunkDistance = (chunkTarget - root.Position).Magnitude
			local chunkTime = chunkDistance / CONFIG.TELEPORT_SPEED
			
			local tweenInfo = TweenInfo.new(
				chunkTime,
				Enum.EasingStyle.Linear,
				Enum.EasingDirection.Out
			)
			
			local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame_new(chunkTarget)})
			tween:Play()
			tween.Completed:Wait()
			
			task.wait(0.1)
		end
	else
		local tweenInfo = TweenInfo.new(
			travelTime,
			Enum.EasingStyle.Linear,
			Enum.EasingDirection.Out
		)
		
		local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame_new(targetPosition)})
		tween:Play()
		tween.Completed:Wait()
	end
	
	state.isTeleporting = false
	return true
end

local function safeTeleportToNPC(npcName)
	local root, _, _ = getCharComponents()
	if not root then return false, "Character not found" end
	
	for _, npc in ipairs(CONFIG.TELEPORT_NPC_FOLDER:GetChildren()) do
		if npc.Name == npcName and npc:IsA("Model") then
			local npcRoot = npc:FindFirstChild("HumanoidRootPart")
			if npcRoot then
				local targetPos = npcRoot.Position + Vector3_new(0, 2, 5)
				
				task.spawn(function()
					ultraSmoothTeleport(targetPos)
				end)
				
				return true, "Teleporting..."
			end
		end
	end
	
	return false, "NPC not found"
end

local function getNPCList()
	local npcList = {}
	for _, npc in ipairs(CONFIG.TELEPORT_NPC_FOLDER:GetChildren()) do
		if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
			if not table.find(npcList, npc.Name) then
				table.insert(npcList, npc.Name)
			end
		end
	end
	table.sort(npcList)
	return npcList
end

-- ===== LOCK ON TARGET =====
local function lockOnLoop()
	if not state.lockOnEnabled then return end
	
	local camera = workspace.CurrentCamera
	local target = state.lockedTarget
	
	if state.autofarmEnabled and state.lockedNPC then
		target = state.lockedNPC
	end
	
	if not target or not target.Parent then
		target = findClosestNPC()
		state.lockedTarget = target
	end
	
	if target then
		local npcRoot = target:FindFirstChild("HumanoidRootPart")
		if npcRoot then
			camera.CFrame = CFrame_new(camera.CFrame.Position, npcRoot.Position)
		end
	end
end

-- ===== M1 MACRO =====
local function simulateMouseClick()
	local virtualInput = game:GetService("VirtualInputManager")
	virtualInput:SendMouseButtonEvent(0, 0, 0, true, game, 0)
	task.wait(0.01)
	virtualInput:SendMouseButtonEvent(0, 0, 0, false, game, 0)
end

local function m1MacroLoop()
	if not state.m1MacroEnabled then return end
	local now = tick()
	if now - state.lastM1Click >= state.m1ClickDelay then
		pcall(simulateMouseClick)
		state.lastM1Click = now
	end
end

-- ===== AUTOFARM (DUAL MODE) =====
local function isNPCValid(npc)
	if not npc or not npc.Parent then return false end
	local hum = npc:FindFirstChild("Humanoid")
	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not hum or not npcRoot or hum.Health <= 0 then return false end
	
	local root, _, _ = getCharComponents()
	if not root then return false end
	
	local dist = (root.Position - npcRoot.Position).Magnitude
	return dist <= CONFIG.MAX_DISTANCE
end

local function autofarmLoop()
	if not state.autofarmEnabled then return end
	local root, _, _ = getCharComponents()
	if not root then return end

	if not isNPCValid(state.lockedNPC) then
		state.lockedNPC = findClosestNPC()
	end

	local npc = state.lockedNPC
	if not npc then return end

	local npcRoot = npc:FindFirstChild("HumanoidRootPart")
	if not npcRoot then
		state.lockedNPC = nil
		return
	end

	local targetCFrame
	
	if state.autofarmMode == "Above" then
		-- Above NPC: jogador acima do NPC e "deitado" (horizontal, como nas imagens)
		local abovePos = npcRoot.Position + Vector3_new(0, CONFIG.ABOVE_HEIGHT, 0)
		local rotacaoDeitado = CFrame.Angles(math.rad(90), 0, 0) -- 90¬∞ no X = personagem deitado
		targetCFrame = CFrame_new(abovePos) * rotacaoDeitado
	else
		-- Behind NPC: atr√°s do NPC (padr√£o)
		local npcCFrame = npcRoot.CFrame
		local backVector = -npcCFrame.LookVector * CONFIG.BACK_DISTANCE
		local upVector = Vector3_new(0, CONFIG.HEIGHT_OFFSET, 0)
		targetCFrame = CFrame_new(npcRoot.Position + backVector + upVector)
	end

	root.AssemblyLinearVelocity = Vector3_zero
	root.AssemblyAngularVelocity = Vector3_zero
	root.CFrame = targetCFrame
end

-- ===== SPEED BOOST =====
local function speedLoop()
	if not state.speedEnabled then return end
	local root, hum, _ = getCharComponents()
	if root and hum then
		local moveDir = hum.MoveDirection
		if moveDir.Magnitude > 0 then
			local currentY = root.AssemblyLinearVelocity.Y
			root.AssemblyLinearVelocity = (moveDir.Unit * state.speedValue) + Vector3_new(0, currentY, 0)
		end
	end
end

-- ===== NO CLIP =====
local function enableNoClip()
	local char = player.Character
	if not char then return end
	
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
		end
	end
end

local function disableNoClip()
	local char = player.Character
	if not char then return end
	
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			part.CanCollide = true
		end
	end
end

-- ===== CLEANUP OLD GUI =====
pcall(function()
	CoreGui:FindFirstChild(CONFIG.GUI_NAME):Destroy()
end)

-- ===== GUI CREATION =====
local screenGui = Instance.new("ScreenGui")
screenGui.Name = CONFIG.GUI_NAME
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = CoreGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2_new(0, 320, 0, 450)
mainFrame.Position = UDim2_new(0, 20, 0.5, -225)
mainFrame.BackgroundColor3 = Color3_fromRGB(13, 13, 18)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

local borderGradient = Instance.new("UIStroke")
borderGradient.Color = Color3_fromRGB(100, 100, 120)
borderGradient.Thickness = 1
borderGradient.Transparency = 0.5
borderGradient.Parent = mainFrame

local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2_new(1, 0, 0, 35)
header.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
header.BorderSizePixel = 0
header.Parent = mainFrame

local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 8)
headerCorner.Parent = header

local headerFill = Instance.new("Frame")
headerFill.Size = UDim2_new(1, 0, 0, 8)
headerFill.Position = UDim2_new(0, 0, 1, -8)
headerFill.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
headerFill.BorderSizePixel = 0
headerFill.Parent = header

local titleContainer = Instance.new("Frame")
titleContainer.Size = UDim2_new(1, -80, 1, 0)
titleContainer.Position = UDim2_new(0, 10, 0, 0)
titleContainer.BackgroundTransparency = 1
titleContainer.Parent = header

local titleIcon = Instance.new("TextLabel")
titleIcon.Size = UDim2_new(0, 20, 1, 0)
titleIcon.BackgroundTransparency = 1
titleIcon.Text = "‚ú¶"
titleIcon.Font = Enum.Font.GothamBold
titleIcon.TextSize = 16
titleIcon.TextColor3 = Color3_fromRGB(100, 180, 255)
titleIcon.TextXAlignment = Enum.TextXAlignment.Left
titleIcon.Parent = titleContainer

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2_new(1, -25, 1, 0)
titleLabel.Position = UDim2_new(0, 25, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "CYBER HUB"
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 13
titleLabel.TextColor3 = Color3_white
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleContainer

local versionLabel = Instance.new("TextLabel")
versionLabel.Size = UDim2_new(0, 80, 1, 0)
versionLabel.Position = UDim2_new(1, -90, 0, 0)
versionLabel.BackgroundTransparency = 1
versionLabel.Text = "4.3"
versionLabel.Font = Enum.Font.Gotham
versionLabel.TextSize = 11
versionLabel.TextColor3 = Color3_fromRGB(120, 120, 140)
versionLabel.TextXAlignment = Enum.TextXAlignment.Right
versionLabel.Parent = header

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2_new(0, 25, 0, 25)
closeBtn.Position = UDim2_new(1, -30, 0, 5)
closeBtn.BackgroundColor3 = Color3_fromRGB(25, 25, 35)
closeBtn.Text = "√ó"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 18
closeBtn.TextColor3 = Color3_fromRGB(200, 200, 210)
closeBtn.BorderSizePixel = 0
closeBtn.Parent = header

local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(0, 4)
closeBtnCorner.Parent = closeBtn

closeBtn.MouseButton1Click:Connect(function()
	screenGui:Destroy()
end)

local sidebar = Instance.new("Frame")
sidebar.Name = "Sidebar"
sidebar.Size = UDim2_new(0, 45, 1, -40)
sidebar.Position = UDim2_new(0, 5, 0, 38)
sidebar.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
sidebar.BorderSizePixel = 0
sidebar.Parent = mainFrame

local sidebarCorner = Instance.new("UICorner")
sidebarCorner.CornerRadius = UDim.new(0, 6)
sidebarCorner.Parent = sidebar

local sidebarLayout = Instance.new("UIListLayout")
sidebarLayout.Padding = UDim.new(0, 5)
sidebarLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
sidebarLayout.Parent = sidebar

local sidebarPadding = Instance.new("UIPadding")
sidebarPadding.PaddingTop = UDim.new(0, 8)
sidebarPadding.Parent = sidebar

local function createSidebarBtn(icon, name)
	local btn = Instance.new("TextButton")
	btn.Name = name
	btn.Size = UDim2_new(0, 35, 0, 35)
	btn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	btn.Text = icon
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 16
	btn.TextColor3 = Color3_fromRGB(120, 120, 140)
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = false
	btn.Parent = sidebar
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = btn
	
	return btn
end

local combatBtn = createSidebarBtn("‚öî", "CombatBtn")
local visualBtn = createSidebarBtn("üëÅ", "VisualBtn")
local teleportBtn = createSidebarBtn("üìç", "TeleportBtn")
local miscBtn = createSidebarBtn("üîß", "MiscBtn")

local contentArea = Instance.new("Frame")
contentArea.Name = "ContentArea"
contentArea.Size = UDim2_new(1, -60, 1, -40)
contentArea.Position = UDim2_new(0, 55, 0, 38)
contentArea.BackgroundTransparency = 1
contentArea.Parent = mainFrame

local function createPage(name)
	local page = Instance.new("ScrollingFrame")
	page.Name = name
	page.Size = UDim2_new(1, -5, 1, 0)
	page.BackgroundTransparency = 1
	page.BorderSizePixel = 0
	page.ScrollBarThickness = 3
	page.ScrollBarImageColor3 = Color3_fromRGB(80, 80, 100)
	page.CanvasSize = UDim2_new(0, 0, 0, 0)
	page.AutomaticCanvasSize = Enum.AutomaticSize.Y
	page.Visible = false
	page.Parent = contentArea
	
	local pageLayout = Instance.new("UIListLayout")
	pageLayout.Padding = UDim.new(0, 8)
	pageLayout.SortOrder = Enum.SortOrder.LayoutOrder
	pageLayout.Parent = page
	
	local pagePadding = Instance.new("UIPadding")
	pagePadding.PaddingRight = UDim.new(0, 5)
	pagePadding.Parent = page
	
	return page
end

local combatPage = createPage("CombatPage")
local visualPage = createPage("VisualPage")
local teleportPage = createPage("TeleportPage")
local miscPage = createPage("MiscPage")

local function switchPage(page, btn)
	combatPage.Visible = false
	visualPage.Visible = false
	teleportPage.Visible = false
	miscPage.Visible = false
	
	combatBtn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	combatBtn.TextColor3 = Color3_fromRGB(120, 120, 140)
	visualBtn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	visualBtn.TextColor3 = Color3_fromRGB(120, 120, 140)
	teleportBtn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	teleportBtn.TextColor3 = Color3_fromRGB(120, 120, 140)
	miscBtn.BackgroundColor3 = Color3_fromRGB(22, 22, 30)
	miscBtn.TextColor3 = Color3_fromRGB(120, 120, 140)
	
	page.Visible = true
	btn.BackgroundColor3 = Color3_fromRGB(100, 180, 255)
	btn.TextColor3 = Color3_white
end

combatBtn.MouseButton1Click:Connect(function()
	switchPage(combatPage, combatBtn)
end)

visualBtn.MouseButton1Click:Connect(function()
	switchPage(visualPage, visualBtn)
end)

teleportBtn.MouseButton1Click:Connect(function()
	switchPage(teleportPage, teleportBtn)
end)

miscBtn.MouseButton1Click:Connect(function()
	switchPage(miscPage, miscBtn)
end)

switchPage(combatPage, combatBtn)

local function createSectionHeader(parent, text)
	local header = Instance.new("Frame")
	header.Size = UDim2_new(1, 0, 0, 30)
	header.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
	header.BorderSizePixel = 0
	header.Parent = parent
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 6)
	headerCorner.Parent = header
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2_new(1, -15, 1, 0)
	label.Position = UDim2_new(0, 10, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.Font = Enum.Font.GothamBold
	label.TextSize = 12
	label.TextColor3 = Color3_fromRGB(180, 180, 200)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = header
	
	local icon = Instance.new("TextLabel")
	icon.Size = UDim2_new(0, 15, 1, 0)
	icon.BackgroundTransparency = 1
	icon.Text = "‚óá"
	icon.Font = Enum.Font.GothamBold
	icon.TextSize = 10
	icon.TextColor3 = Color3_fromRGB(100, 180, 255)
	icon.TextXAlignment = Enum.TextXAlignment.Left
	icon.Parent = label
	
	return header
end

local function createToggle(parent, labelText, descText, defaultState)
	local container = Instance.new("Frame")
	container.Size = UDim2_new(1, 0, 0, descText and 55 or 40)
	container.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
	container.BorderSizePixel = 0
	container.Parent = parent
	
	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 6)
	containerCorner.Parent = container
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2_new(0.7, -10, 0, 20)
	label.Position = UDim2_new(0, 10, 0, descText and 8 or 10)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = Enum.Font.Gotham
	label.TextSize = 12
	label.TextColor3 = Color3_white
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = container
	
	if descText then
		local desc = Instance.new("TextLabel")
		desc.Size = UDim2_new(1, -20, 0, 18)
		desc.Position = UDim2_new(0, 10, 0, 28)
		desc.BackgroundTransparency = 1
		desc.Text = descText
		desc.Font = Enum.Font.Gotham
		desc.TextSize = 9
		desc.TextColor3 = Color3_fromRGB(120, 120, 140)
		desc.TextXAlignment = Enum.TextXAlignment.Left
		desc.TextWrapped = true
		desc.Parent = container
	end
	
	local toggleBg = Instance.new("Frame")
	toggleBg.Size = UDim2_new(0, 38, 0, 20)
	toggleBg.Position = UDim2_new(1, -45, 0, descText and 10 or 10)
	toggleBg.BackgroundColor3 = defaultState and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	toggleBg.BorderSizePixel = 0
	toggleBg.Parent = container
	
	local toggleBgCorner = Instance.new("UICorner")
	toggleBgCorner.CornerRadius = UDim.new(1, 0)
	toggleBgCorner.Parent = toggleBg
	
	local toggleCircle = Instance.new("Frame")
	toggleCircle.Size = UDim2_new(0, 16, 0, 16)
	toggleCircle.Position = defaultState and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	toggleCircle.BackgroundColor3 = Color3_white
	toggleCircle.BorderSizePixel = 0
	toggleCircle.Parent = toggleBg
	
	local toggleCircleCorner = Instance.new("UICorner")
	toggleCircleCorner.CornerRadius = UDim.new(1, 0)
	toggleCircleCorner.Parent = toggleCircle
	
	local toggleBtn = Instance.new("TextButton")
	toggleBtn.Size = UDim2_new(1, 0, 1, 0)
	toggleBtn.BackgroundTransparency = 1
	toggleBtn.Text = ""
	toggleBtn.Parent = toggleBg
	
	return container, toggleBtn, toggleBg, toggleCircle
end

local function createSlider(parent, labelText, minVal, maxVal, defaultVal)
	local container = Instance.new("Frame")
	container.Size = UDim2_new(1, 0, 0, 50)
	container.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
	container.BorderSizePixel = 0
	container.Parent = parent
	
	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 6)
	containerCorner.Parent = container
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2_new(0.6, 0, 0, 18)
	label.Position = UDim2_new(0, 10, 0, 8)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = Enum.Font.Gotham
	label.TextSize = 11
	label.TextColor3 = Color3_white
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = container
	
	local valueLabel = Instance.new("TextLabel")
	valueLabel.Size = UDim2_new(0, 50, 0, 18)
	valueLabel.Position = UDim2_new(1, -55, 0, 8)
	valueLabel.BackgroundTransparency = 1
	valueLabel.Text = tostring(defaultVal)
	valueLabel.Font = Enum.Font.GothamBold
	valueLabel.TextSize = 11
	valueLabel.TextColor3 = Color3_fromRGB(100, 180, 255)
	valueLabel.TextXAlignment = Enum.TextXAlignment.Right
	valueLabel.Parent = container
	
	local sliderBg = Instance.new("Frame")
	sliderBg.Size = UDim2_new(1, -20, 0, 4)
	sliderBg.Position = UDim2_new(0, 10, 1, -15)
	sliderBg.BackgroundColor3 = Color3_fromRGB(30, 30, 42)
	sliderBg.BorderSizePixel = 0
	sliderBg.Parent = container
	
	local sliderBgCorner = Instance.new("UICorner")
	sliderBgCorner.CornerRadius = UDim.new(1, 0)
	sliderBgCorner.Parent = sliderBg
	
	local sliderFill = Instance.new("Frame")
	sliderFill.Size = UDim2_new((defaultVal - minVal) / (maxVal - minVal), 0, 1, 0)
	sliderFill.BackgroundColor3 = Color3_fromRGB(100, 180, 255)
	sliderFill.BorderSizePixel = 0
	sliderFill.Parent = sliderBg
	
	local sliderFillCorner = Instance.new("UICorner")
	sliderFillCorner.CornerRadius = UDim.new(1, 0)
	sliderFillCorner.Parent = sliderFill
	
	local sliderBtn = Instance.new("TextButton")
	sliderBtn.Size = UDim2_new(1, 0, 1, 10)
	sliderBtn.Position = UDim2_new(0, 0, 0, -5)
	sliderBtn.BackgroundTransparency = 1
	sliderBtn.Text = ""
	sliderBtn.Parent = sliderBg
	
	return container, sliderBtn, sliderFill, valueLabel, minVal, maxVal
end

local function createButton(parent, text, color)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2_new(1, 0, 0, 35)
	btn.BackgroundColor3 = color or Color3_fromRGB(100, 180, 255)
	btn.Text = text
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 12
	btn.TextColor3 = Color3_white
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = false
	btn.Parent = parent
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = btn
	
	return btn
end

local function createDropdown(parent, labelText, options, defaultOption)
	local container = Instance.new("Frame")
	container.Size = UDim2_new(1, 0, 0, 50)
	container.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
	container.BorderSizePixel = 0
	container.Parent = parent
	
	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 6)
	containerCorner.Parent = container
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2_new(1, -20, 0, 18)
	label.Position = UDim2_new(0, 10, 0, 6)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.Font = Enum.Font.GothamBold
	label.TextSize = 11
	label.TextColor3 = Color3_fromRGB(180, 180, 200)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = container
	
	local dropdown = Instance.new("TextButton")
	dropdown.Size = UDim2_new(1, -20, 0, 22)
	dropdown.Position = UDim2_new(0, 10, 0, 24)
	dropdown.BackgroundColor3 = Color3_fromRGB(25, 25, 35)
	dropdown.Text = defaultOption .. "  ‚ñº"
	dropdown.Font = Enum.Font.Gotham
	dropdown.TextSize = 11
	dropdown.TextColor3 = Color3_white
	dropdown.BorderSizePixel = 0
	dropdown.Parent = container
	
	local dropdownCorner = Instance.new("UICorner")
	dropdownCorner.CornerRadius = UDim.new(0, 4)
	dropdownCorner.Parent = dropdown
	
	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.PaddingLeft = UDim.new(0, 8)
	dropdownPadding.Parent = dropdown
	
	local optionsFrame = Instance.new("ScrollingFrame")
	optionsFrame.Name = "OptionsFrame"
	optionsFrame.Size = UDim2_new(1, -20, 0, math.min(#options * 25, 100))
	optionsFrame.Position = UDim2_new(0, 10, 0, 48)
	optionsFrame.BackgroundColor3 = Color3_fromRGB(20, 20, 28)
	optionsFrame.BorderSizePixel = 0
	optionsFrame.ScrollBarThickness = 3
	optionsFrame.ScrollBarImageColor3 = Color3_fromRGB(80, 80, 100)
	optionsFrame.Visible = false
	optionsFrame.ZIndex = 10
	optionsFrame.Parent = container
	
	local optionsCorner = Instance.new("UICorner")
	optionsCorner.CornerRadius = UDim.new(0, 4)
	optionsCorner.Parent = optionsFrame
	
	local optionsLayout = Instance.new("UIListLayout")
	optionsLayout.Padding = UDim.new(0, 2)
	optionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	optionsLayout.Parent = optionsFrame
	
	for _, option in ipairs(options) do
		local optionBtn = Instance.new("TextButton")
		optionBtn.Size = UDim2_new(1, 0, 0, 23)
		optionBtn.BackgroundColor3 = Color3_fromRGB(25, 25, 35)
		optionBtn.Text = option
		optionBtn.Font = Enum.Font.Gotham
		optionBtn.TextSize = 10
		optionBtn.TextColor3 = Color3_white
		optionBtn.BorderSizePixel = 0
		optionBtn.AutoButtonColor = false
		optionBtn.Parent = optionsFrame
		
		optionBtn.MouseEnter:Connect(function()
			optionBtn.BackgroundColor3 = Color3_fromRGB(35, 35, 45)
		end)
		
		optionBtn.MouseLeave:Connect(function()
			optionBtn.BackgroundColor3 = Color3_fromRGB(25, 25, 35)
		end)
		
		optionBtn.MouseButton1Click:Connect(function()
			dropdown.Text = option .. "  ‚ñº"
			optionsFrame.Visible = false
			container.Size = UDim2_new(1, 0, 0, 50)
			
			-- Atualizar o estado
			if labelText == "Farm Position" then
				state.autofarmMode = option
			end
		end)
	end
	
	optionsFrame.CanvasSize = UDim2.new(0, 0, 0, #options * 25)
	
	dropdown.MouseButton1Click:Connect(function()
		optionsFrame.Visible = not optionsFrame.Visible
		if optionsFrame.Visible then
			container.Size = UDim2_new(1, 0, 0, 50 + math.min(#options * 25, 100) + 5)
		else
			container.Size = UDim2_new(1, 0, 0, 50)
		end
	end)
	
	return container, dropdown
end

-- ===== COMBAT PAGE =====
createSectionHeader(combatPage, "Auto Farm Settings")

local autofarmContainer, autofarmToggle, autofarmBg, autofarmCircle = createToggle(
	combatPage,
	"Auto Farm",
	"Automatically farm the closest NPC",
	state.autofarmEnabled
)

-- Farm Position: seletor com duas op√ß√µes vis√≠veis (Behind / Above)
local farmModeContainer = Instance.new("Frame")
farmModeContainer.Name = "FarmModeContainer"
farmModeContainer.Size = UDim2_new(1, 0, 0, 78)
farmModeContainer.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
farmModeContainer.BorderSizePixel = 0
farmModeContainer.Parent = combatPage

local farmModeCorner = Instance.new("UICorner")
farmModeCorner.CornerRadius = UDim.new(0, 6)
farmModeCorner.Parent = farmModeContainer

local farmModeLabel = Instance.new("TextLabel")
farmModeLabel.Size = UDim2_new(1, -20, 0, 18)
farmModeLabel.Position = UDim2_new(0, 10, 0, 6)
farmModeLabel.BackgroundTransparency = 1
farmModeLabel.Text = "Farm Position"
farmModeLabel.Font = Enum.Font.GothamBold
farmModeLabel.TextSize = 11
farmModeLabel.TextColor3 = Color3_fromRGB(180, 180, 200)
farmModeLabel.TextXAlignment = Enum.TextXAlignment.Left
farmModeLabel.Parent = farmModeContainer

-- Frame que cont√©m os dois bot√µes (Behind e Above) sempre vis√≠veis
local farmModeButtonsFrame = Instance.new("Frame")
farmModeButtonsFrame.Name = "FarmPositionButtons"
farmModeButtonsFrame.Size = UDim2_new(1, -20, 0, 44)
farmModeButtonsFrame.Position = UDim2_new(0, 10, 0, 28)
farmModeButtonsFrame.BackgroundTransparency = 1
farmModeButtonsFrame.Parent = farmModeContainer

local farmModeButtonsLayout = Instance.new("UIListLayout")
farmModeButtonsLayout.FillDirection = Enum.FillDirection.Horizontal
farmModeButtonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
farmModeButtonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
farmModeButtonsLayout.Padding = UDim.new(0, 8)
farmModeButtonsLayout.SortOrder = Enum.SortOrder.LayoutOrder
farmModeButtonsLayout.Parent = farmModeButtonsFrame

local farmModeBehindBtn = Instance.new("TextButton")
farmModeBehindBtn.Name = "Option_Behind"
farmModeBehindBtn.LayoutOrder = 1
farmModeBehindBtn.Size = UDim2_new(0, 130, 0, 28)
farmModeBehindBtn.BackgroundColor3 = Color3_fromRGB(100, 180, 255)
farmModeBehindBtn.Text = "Behind"
farmModeBehindBtn.Font = Enum.Font.GothamBold
farmModeBehindBtn.TextSize = 11
farmModeBehindBtn.TextColor3 = Color3_white
farmModeBehindBtn.BorderSizePixel = 0
farmModeBehindBtn.AutoButtonColor = false
farmModeBehindBtn.Parent = farmModeButtonsFrame

local farmModeBehindCorner = Instance.new("UICorner")
farmModeBehindCorner.CornerRadius = UDim.new(0, 6)
farmModeBehindCorner.Parent = farmModeBehindBtn

local farmModeAboveBtn = Instance.new("TextButton")
farmModeAboveBtn.Name = "Option_Above"
farmModeAboveBtn.LayoutOrder = 2
farmModeAboveBtn.Size = UDim2_new(0, 130, 0, 28)
farmModeAboveBtn.BackgroundColor3 = Color3_fromRGB(40, 40, 55)
farmModeAboveBtn.Text = "Above"
farmModeAboveBtn.Font = Enum.Font.GothamBold
farmModeAboveBtn.TextSize = 11
farmModeAboveBtn.TextColor3 = Color3_fromRGB(180, 180, 200)
farmModeAboveBtn.BorderSizePixel = 0
farmModeAboveBtn.AutoButtonColor = false
farmModeAboveBtn.Parent = farmModeButtonsFrame

local farmModeAboveCorner = Instance.new("UICorner")
farmModeAboveCorner.CornerRadius = UDim.new(0, 6)
farmModeAboveCorner.Parent = farmModeAboveBtn

local function updateFarmPositionVisuals()
	local isBehind = (state.autofarmMode == "Behind")
	farmModeBehindBtn.BackgroundColor3 = isBehind and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	farmModeBehindBtn.TextColor3 = isBehind and Color3_white or Color3_fromRGB(180, 180, 200)
	farmModeAboveBtn.BackgroundColor3 = isBehind and Color3_fromRGB(40, 40, 55) or Color3_fromRGB(100, 180, 255)
	farmModeAboveBtn.TextColor3 = isBehind and Color3_fromRGB(180, 180, 200) or Color3_white
end

farmModeBehindBtn.MouseButton1Click:Connect(function()
	state.autofarmMode = "Behind"
	updateFarmPositionVisuals()
end)

farmModeAboveBtn.MouseButton1Click:Connect(function()
	state.autofarmMode = "Above"
	updateFarmPositionVisuals()
end)

farmModeBehindBtn.MouseEnter:Connect(function()
	if state.autofarmMode ~= "Behind" then
		farmModeBehindBtn.BackgroundColor3 = Color3_fromRGB(55, 55, 70)
	end
end)
farmModeBehindBtn.MouseLeave:Connect(function()
	updateFarmPositionVisuals()
end)
farmModeAboveBtn.MouseEnter:Connect(function()
	if state.autofarmMode ~= "Above" then
		farmModeAboveBtn.BackgroundColor3 = Color3_fromRGB(55, 55, 70)
	end
end)
farmModeAboveBtn.MouseLeave:Connect(function()
	updateFarmPositionVisuals()
end)

updateFarmPositionVisuals()

local lockOnContainer, lockOnToggle, lockOnBg, lockOnCircle = createToggle(
	combatPage,
	"Lock On Target",
	"Camera locks onto nearest enemy",
	state.lockOnEnabled
)

local m1Container, m1Toggle, m1Bg, m1Circle = createToggle(
	combatPage,
	"M1 Auto Click (F2)",
	"Automatically click M1 button",
	state.m1MacroEnabled
)

local m1SliderContainer, m1SliderBtn, m1SliderFill, m1ValueLabel, m1Min, m1Max = createSlider(
	combatPage,
	"M1 Click Delay",
	0.05,
	1,
	state.m1ClickDelay
)

createSectionHeader(combatPage, "Movement Settings")

local speedContainer, speedToggle, speedBg, speedCircle = createToggle(
	combatPage,
	"Speed Boost",
	"Increase movement speed",
	state.speedEnabled
)

local speedSliderContainer, speedSliderBtn, speedSliderFill, speedValueLabel, speedMin, speedMax = createSlider(
	combatPage,
	"Speed Value",
	50,
	300,
	state.speedValue
)

local jumpContainer, jumpToggle, jumpBg, jumpCircle = createToggle(
	combatPage,
	"Infinite Jump",
	"Jump infinitely without limit",
	state.infiniteJumpEnabled
)

-- ===== VISUAL PAGE =====
createSectionHeader(visualPage, "NPC Visual Features")

local espContainer, espToggle, espBg, espCircle = createToggle(
	visualPage,
	"ESP Highlights",
	"See NPCs through walls",
	state.espEnabled
)

local tracersContainer, tracersToggle, tracersBg, tracersCircle = createToggle(
	visualPage,
	"Tracers",
	"Lines pointing to NPCs",
	state.tracersEnabled
)

local healthBarsContainer, healthBarsToggle, healthBarsBg, healthBarsCircle = createToggle(
	visualPage,
	"Health Bars",
	"Display NPC health bars",
	state.healthBarsEnabled
)

createSectionHeader(visualPage, "Player Visual Features")

local playerESPContainer, playerESPToggle, playerESPBg, playerESPCircle = createToggle(
	visualPage,
	"Player ESP",
	"See other players through walls",
	playerESPEnabled
)

local fovContainer, fovToggle, fovBg, fovCircle = createToggle(
	visualPage,
	"FOV Circle",
	"Display field of view circle",
	fovEnabled
)

-- ===== TELEPORT PAGE =====
createSectionHeader(teleportPage, "Safe Teleport System")

local tpInfoContainer = Instance.new("Frame")
tpInfoContainer.Size = UDim2_new(1, 0, 0, 60)
tpInfoContainer.BackgroundColor3 = Color3_fromRGB(100, 180, 255)
tpInfoContainer.BackgroundTransparency = 0.9
tpInfoContainer.BorderSizePixel = 0
tpInfoContainer.Parent = teleportPage

local tpInfoCorner = Instance.new("UICorner")
tpInfoCorner.CornerRadius = UDim.new(0, 6)
tpInfoCorner.Parent = tpInfoContainer

local tpInfoLabel = Instance.new("TextLabel")
tpInfoLabel.Size = UDim2_new(1, -20, 1, 0)
tpInfoLabel.Position = UDim2_new(0, 10, 0, 0)
tpInfoLabel.BackgroundTransparency = 1
tpInfoLabel.Text = "üìç Ultra Smooth Teleport\nAnti-kick protection for long distances\nClick any NPC to teleport safely"
tpInfoLabel.Font = Enum.Font.Gotham
tpInfoLabel.TextSize = 10
tpInfoLabel.TextColor3 = Color3_white
tpInfoLabel.TextXAlignment = Enum.TextXAlignment.Left
tpInfoLabel.TextWrapped = true
tpInfoLabel.Parent = tpInfoContainer

local refreshNPCBtn = createButton(teleportPage, "üîÑ Refresh NPC List", Color3_fromRGB(80, 200, 120))

local npcListContainer = Instance.new("Frame")
npcListContainer.Name = "NPCListContainer"
npcListContainer.Size = UDim2_new(1, 0, 0, 0)
npcListContainer.AutomaticSize = Enum.AutomaticSize.Y
npcListContainer.BackgroundTransparency = 1
npcListContainer.Parent = teleportPage

local npcListLayout = Instance.new("UIListLayout")
npcListLayout.Padding = UDim.new(0, 5)
npcListLayout.SortOrder = Enum.SortOrder.LayoutOrder
npcListLayout.Parent = npcListContainer

local function populateNPCList()
	for _, child in ipairs(npcListContainer:GetChildren()) do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end
	
	local npcList = getNPCList()
	state.teleportNPCList = npcList
	
	for _, npcName in ipairs(npcList) do
		local npcBtn = Instance.new("TextButton")
		npcBtn.Size = UDim2_new(1, 0, 0, 32)
		npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
		npcBtn.Text = "   üìå " .. npcName
		npcBtn.Font = Enum.Font.Gotham
		npcBtn.TextSize = 11
		npcBtn.TextColor3 = Color3_white
		npcBtn.TextXAlignment = Enum.TextXAlignment.Left
		npcBtn.BorderSizePixel = 0
		npcBtn.AutoButtonColor = false
		npcBtn.Parent = npcListContainer
		
		local npcBtnCorner = Instance.new("UICorner")
		npcBtnCorner.CornerRadius = UDim.new(0, 6)
		npcBtnCorner.Parent = npcBtn
		
		npcBtn.MouseEnter:Connect(function()
			npcBtn.BackgroundColor3 = Color3_fromRGB(25, 25, 35)
		end)
		
		npcBtn.MouseLeave:Connect(function()
			npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
		end)
		
		npcBtn.MouseButton1Click:Connect(function()
			local success, msg = safeTeleportToNPC(npcName)
			if success then
				npcBtn.BackgroundColor3 = Color3_fromRGB(80, 200, 120)
				task.wait(0.5)
				npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
			else
				npcBtn.BackgroundColor3 = Color3_fromRGB(200, 50, 50)
				task.wait(0.5)
				npcBtn.BackgroundColor3 = Color3_fromRGB(18, 18, 25)
			end
		end)
	end
end

refreshNPCBtn.MouseButton1Click:Connect(populateNPCList)

task.spawn(function()
	task.wait(1)
	populateNPCList()
end)

-- ===== MISC PAGE =====
createSectionHeader(miscPage, "Misc Features")

local noClipContainer, noClipToggle, noClipBg, noClipCircle = createToggle(
	miscPage,
	"No Clip",
	"Walk through walls",
	noClipEnabled
)

-- ===== TOGGLE FUNCTIONS =====
toggleUpdateFunctions.autofarm = function(enabled)
	state.autofarmEnabled = enabled
	
	TweenService:Create(autofarmBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(autofarmCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("autofarm")
		state.connections.autofarm = RunService.Heartbeat:Connect(autofarmLoop)
	else
		disconnectConnection("autofarm")
		state.lockedNPC = nil
	end
end

autofarmToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.autofarm(not state.autofarmEnabled)
end)

toggleUpdateFunctions.lockOn = function(enabled)
	state.lockOnEnabled = enabled
	
	TweenService:Create(lockOnBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(lockOnCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("lockOn")
		state.connections.lockOn = RunService.RenderStepped:Connect(lockOnLoop)
	else
		disconnectConnection("lockOn")
		state.lockedTarget = nil
	end
end

lockOnToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.lockOn(not state.lockOnEnabled)
end)

toggleUpdateFunctions.m1Macro = function(enabled)
	state.m1MacroEnabled = enabled
	
	TweenService:Create(m1Bg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(m1Circle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("m1macro")
		state.connections.m1macro = RunService.Heartbeat:Connect(m1MacroLoop)
	else
		disconnectConnection("m1macro")
	end
end

m1Toggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.m1Macro(not state.m1MacroEnabled)
end)

local m1Dragging = false
m1SliderBtn.MouseButton1Down:Connect(function()
	m1Dragging = true
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		m1Dragging = false
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if m1Dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local sliderBg = m1SliderBtn.Parent
		local mousePos = UserInputService:GetMouseLocation().X
		local sliderPos = sliderBg.AbsolutePosition.X
		local sliderSize = sliderBg.AbsoluteSize.X
		local percent = math.clamp((mousePos - sliderPos) / sliderSize, 0, 1)
		local value = m1Min + (percent * (m1Max - m1Min))
		value = math.floor(value * 100) / 100
		
		state.m1ClickDelay = value
		m1ValueLabel.Text = tostring(value)
		m1SliderFill.Size = UDim2_new(percent, 0, 1, 0)
	end
end)

toggleUpdateFunctions.speed = function(enabled)
	state.speedEnabled = enabled
	
	TweenService:Create(speedBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(speedCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		disconnectConnection("speed")
		state.connections.speed = RunService.Heartbeat:Connect(speedLoop)
	else
		disconnectConnection("speed")
	end
end

speedToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.speed(not state.speedEnabled)
end)

local speedDragging = false
speedSliderBtn.MouseButton1Down:Connect(function()
	speedDragging = true
end)

UserInputService.InputChanged:Connect(function(input)
	if speedDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local sliderBg = speedSliderBtn.Parent
		local mousePos = UserInputService:GetMouseLocation().X
		local sliderPos = sliderBg.AbsolutePosition.X
		local sliderSize = sliderBg.AbsoluteSize.X
		local percent = math.clamp((mousePos - sliderPos) / sliderSize, 0, 1)
		local value = speedMin + (percent * (speedMax - speedMin))
		value = math.floor(value)
		
		state.speedValue = value
		speedValueLabel.Text = tostring(value)
		speedSliderFill.Size = UDim2_new(percent, 0, 1, 0)
	end
end)

toggleUpdateFunctions.infiniteJump = function(enabled)
	state.infiniteJumpEnabled = enabled
	
	TweenService:Create(jumpBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(jumpCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
end

jumpToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.infiniteJump(not state.infiniteJumpEnabled)
end)

toggleUpdateFunctions.noClip = function(enabled)
	noClipEnabled = enabled
	
	TweenService:Create(noClipBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(noClipCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		enableNoClip()
		disconnectConnection("noClip")
		state.connections.noClip = RunService.Heartbeat:Connect(function()
			if noClipEnabled then
				enableNoClip()
			end
		end)
	else
		disableNoClip()
		disconnectConnection("noClip")
	end
end

noClipToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.noClip(not noClipEnabled)
end)

toggleUpdateFunctions.esp = function(enabled)
	state.espEnabled = enabled
	
	TweenService:Create(espBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(espCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if not enabled then
		clearAllESP()
	end
end

espToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.esp(not state.espEnabled)
end)

toggleUpdateFunctions.tracers = function(enabled)
	state.tracersEnabled = enabled
	
	TweenService:Create(tracersBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(tracersCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if not enabled then
		clearAllTracers()
	end
end

tracersToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.tracers(not state.tracersEnabled)
end)

toggleUpdateFunctions.healthBars = function(enabled)
	state.healthBarsEnabled = enabled
	
	TweenService:Create(healthBarsBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(healthBarsCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if not enabled then
		clearAllHealthBars()
	end
end

healthBarsToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.healthBars(not state.healthBarsEnabled)
end)

toggleUpdateFunctions.playerESP = function(enabled)
	playerESPEnabled = enabled
	
	TweenService:Create(playerESPBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(playerESPCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
end

playerESPToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.playerESP(not playerESPEnabled)
end)

toggleUpdateFunctions.fov = function(enabled)
	fovEnabled = enabled
	
	TweenService:Create(fovBg, TweenInfo.new(0.2), {
		BackgroundColor3 = enabled and Color3_fromRGB(100, 180, 255) or Color3_fromRGB(40, 40, 55)
	}):Play()
	
	TweenService:Create(fovCircle, TweenInfo.new(0.2), {
		Position = enabled and UDim2_new(1, -18, 0.5, -8) or UDim2_new(0, 2, 0.5, -8)
	}):Play()
	
	if enabled then
		createFOVCircle()
	else
		removeFOVCircle()
	end
end

fovToggle.MouseButton1Click:Connect(function()
	toggleUpdateFunctions.fov(not fovEnabled)
end)

-- ===== VISUAL UPDATE LOOP =====
state.connections.visualUpdate = RunService.RenderStepped:Connect(function()
	updateVisuals()
	updatePlayerESP()
	updateFOVCircle()
end)

-- ===== INPUT HANDLING =====
UserInputService.JumpRequest:Connect(function()
	if state.infiniteJumpEnabled then
		local _, hum, _ = getCharComponents()
		if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
	end
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end

	if input.KeyCode == Enum.KeyCode.F1 then
		state.guiVisible = not state.guiVisible
		mainFrame.Visible = state.guiVisible
	end

	if input.KeyCode == Enum.KeyCode.F2 then
		toggleUpdateFunctions.m1Macro(not state.m1MacroEnabled)
	end
end)

-- ===== CHARACTER EVENTS =====
player.CharacterAdded:Connect(function(char)
	invalidateCharCache()
	task.wait(0.3)
	
	if state.speedEnabled then
		disconnectConnection("speed")
		state.connections.speed = RunService.Heartbeat:Connect(speedLoop)
	end
	if state.m1MacroEnabled then
		disconnectConnection("m1macro")
		state.connections.m1macro = RunService.Heartbeat:Connect(m1MacroLoop)
	end
end)

-- ===== CLEANUP =====
screenGui.Destroying:Connect(function()
	cleanAllConnections()
	clearAllESP()
	clearAllTracers()
	clearAllHealthBars()
	removeFOVCircle()
	for player, esp in pairs(playerESPObjects) do
		if esp then esp:Destroy() end
	end
end)

-- ===== STARTUP =====
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("        CYBER HUB - FFRE EDITION V4.3")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  ‚öîÔ∏è  Combat: Auto Farm (Behind/Above)")
print("  üéØ  Lock On | M1 Macro")
print("  üöÄ  Movement: Speed | Infinite Jump | No Clip")
print("  üëÅÔ∏è  Visual: ESP | Tracers | Health Bars")
print("  üìç  Teleport: Ultra Smooth (Anti-Kick)")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  F1 - Toggle GUI | F2 - Toggle M1 Macro")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
